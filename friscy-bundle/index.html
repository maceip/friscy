<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>friscy container</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 1rem;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        h1 { font-size: 1.2rem; font-weight: 500; }
        .status { font-size: 0.85rem; color: #888; margin-top: 0.25rem; }
        #terminal-container {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent scrollbars from container itself */
        }
        #terminal {
            flex: 1;
            border-radius: 8px;
            overflow: hidden;
            display: flex; /* Ensure terminal content fills space */
        }
        .xterm-viewport {
             overflow-y: auto; /* Enable scroll for terminal content */
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 1.1rem;
            text-align: center;
        }
        .loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 1rem;
            flex-shrink: 0;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .terminal-actions button {
            background-color: #0f3460;
            color: #eee;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }
        .terminal-actions button:hover {
            background-color: #16213e;
        }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>friscy container</h1>
            <div class="status" id="status">Loading...</div>
        </div>
        <div class="terminal-actions">
            <button id="fit-button">Fit Terminal</button>
            <button id="reset-button">Reset</button>
        </div>
    </header>
    <div id="terminal-container">
        <div id="terminal" class="loading">Initializing container...</div>
    </div>

    <!-- Register service worker -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('Service Worker registration failed: ', registrationError);
                    });
            });
        }
    </script>

    <!-- Import xterm.js and addons as ES Modules from CDN -->
    <script type="module">
        import { Terminal } from 'https://cdn.jsdelivr.net/npm/xterm@5.3.0/+esm';
        import { FitAddon } from 'https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/+esm';
        import createFriscy from './friscy.js';

        const statusEl = document.getElementById('status');
        const terminalEl = document.getElementById('terminal');

        let term, fitAddon, friscyModule;
        const inputBuffer = [];
        let machineRunning = false;
        let resumeScheduled = false;

        function updateTerminalSize() {
            if (friscyModule && term && fitAddon) {
                fitAddon.fit();
                friscyModule._termRows = term.rows;
                friscyModule._termCols = term.cols;
            }
        }

        // Resume the RISC-V machine when it's waiting for stdin.
        // Called on keyboard input and after callMain returns.
        function scheduleResume() {
            if (!machineRunning || resumeScheduled) return;
            const stopped = friscyModule._friscy_stopped;
            if (!stopped || !stopped()) return;

            resumeScheduled = true;
            setTimeout(() => {
                resumeScheduled = false;
                if (!machineRunning) return;

                friscyModule._friscy_resume();

                if (friscyModule._friscy_stopped()) {
                    // Still waiting for more stdin — resume again if buffer has data
                    if (inputBuffer.length > 0) {
                        scheduleResume();
                    } else {
                        // Machine idle, waiting for input — show prompt
                        term.write('\x1b[32m/ # \x1b[0m');
                    }
                } else {
                    // Machine finished (guest called exit)
                    machineRunning = false;
                    term.writeln('\r\n\x1b[33mProcess exited\x1b[0m');
                    statusEl.textContent = 'Exited';
                }
            }, 5);
        }

        async function main() {
            statusEl.textContent = 'Loading manifest...';
            const manifest = await fetch('./manifest.json').then(r => r.json());
            statusEl.textContent = `Image: ${manifest.image}`;

            // Initialize xterm.js
            terminalEl.innerHTML = '';
            terminalEl.classList.remove('loading');

            term = new Terminal({
                cursorBlink: true,
                convertEol: true,
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#0d1117',
                    foreground: '#c9d1d9',
                    selectionBackground: '#00507a',
                    cursor: '#c9d1d9',
                    black: '#000000',
                    red: '#e06c75',
                    green: '#98c379',
                    yellow: '#e5c07b',
                    blue: '#61afef',
                    magenta: '#c678dd',
                    cyan: '#56b6c2',
                    white: '#ffffff',
                    brightBlack: '#5c6370',
                    brightRed: '#e06c75',
                    brightGreen: '#98c379',
                    brightYellow: '#e5c07b',
                    brightBlue: '#61afef',
                    brightMagenta: '#c678dd',
                    brightCyan: '#56b6c2',
                    brightWhite: '#ffffff',
                }
            });
            fitAddon = new FitAddon();
            term.loadAddon(fitAddon);
            term.open(terminalEl);
            term.focus();
            updateTerminalSize();

            window.addEventListener('resize', updateTerminalSize);
            document.getElementById('fit-button').addEventListener('click', updateTerminalSize);
            // Re-focus terminal when user clicks on it
            terminalEl.addEventListener('click', () => term.focus());

            term.writeln('\x1b[1;32mfriscy\x1b[0m - Container runtime in WebAssembly');
            term.writeln(`Loading ${manifest.image}...`);
            term.writeln('');

            // Load rootfs
            statusEl.textContent = 'Loading rootfs...';
            const rootfs = await fetch('./rootfs.tar').then(r => r.arrayBuffer());
            term.writeln(`Loaded rootfs: ${(rootfs.byteLength / 1024 / 1024).toFixed(1)} MB`);

            // Initialize friscy Wasm module
            statusEl.textContent = 'Initializing runtime...';
            friscyModule = await createFriscy({
                noInitialRun: true,
                print: (text) => term.writeln(text),
                printErr: (text) => term.writeln('\x1b[31m' + text + '\x1b[0m'),
                _stdinBuffer: inputBuffer,
                _stdinEOF: false,
                _termRows: term.rows,
                _termCols: term.cols,
                _termWrite: (text) => term.write(text),
            });

            // Load rootfs into Emscripten virtual FS
            friscyModule.FS.writeFile('/rootfs.tar', new Uint8Array(rootfs));

            // Wire keyboard → stdin buffer → machine resume
            // Shell runs in batch mode (no TTY echo), so we provide:
            //   - Local echo for visual feedback
            //   - Line buffering with backspace support
            //   - \r → \n translation (xterm sends \r, Unix needs \n)
            let lineBuffer = '';

            term.onData((data) => {
                if (!machineRunning) return;

                for (const ch of data) {
                    const code = ch.charCodeAt(0);

                    if (ch === '\r') {
                        // Enter → send buffered line + \n to shell
                        term.write('\r\n');
                        const line = lineBuffer + '\n';
                        const bytes = new TextEncoder().encode(line);
                        inputBuffer.push(...bytes);
                        lineBuffer = '';
                        scheduleResume();
                    } else if (code === 127 || code === 8) {
                        // Backspace
                        if (lineBuffer.length > 0) {
                            lineBuffer = lineBuffer.slice(0, -1);
                            term.write('\b \b');
                        }
                    } else if (code === 3) {
                        // Ctrl+C
                        term.write('^C\r\n');
                        lineBuffer = '';
                    } else if (code === 4) {
                        // Ctrl+D → EOF when line is empty
                        if (lineBuffer.length === 0) {
                            friscyModule._stdinEOF = true;
                            scheduleResume();
                        }
                    } else if (code >= 32) {
                        // Printable character → echo and buffer
                        term.write(ch);
                        lineBuffer += ch;
                    }
                }
            });

            // Build args matching main.cpp: --rootfs <tar> <entry> [args...]
            const guestCmd = manifest.entrypoint.split(' ').filter(s => s);
            const args = ['--rootfs', '/rootfs.tar', ...guestCmd];

            statusEl.textContent = 'Running...';
            term.writeln('Starting: ' + manifest.entrypoint);
            term.writeln('\u2500'.repeat(40));

            // Run the container
            try {
                machineRunning = true;
                friscyModule.callMain(args);

                // If machine stopped for stdin, enter interactive mode
                if (friscyModule._friscy_stopped && friscyModule._friscy_stopped()) {
                    statusEl.textContent = 'Interactive';
                    scheduleResume();
                } else {
                    machineRunning = false;
                    term.writeln('\r\n\x1b[33mProcess exited\x1b[0m');
                    statusEl.textContent = 'Exited';
                }
            } catch (e) {
                machineRunning = false;
                term.writeln('\x1b[31mError: ' + e.message + '\x1b[0m');
                statusEl.textContent = 'Error';
                console.error(e);
            }
        }

        document.getElementById('reset-button').addEventListener('click', () => location.reload());

        main().catch(e => {
            console.error(e);
            statusEl.textContent = 'Error: ' + e.message;
        });
    </script>
</body>
</html>
