#!/bin/bash
#
# friscy-pack: Package Docker container for browser execution
#
# Usage:
#   friscy-pack <image> [--output <dir>] [--aot]
#
# Examples:
#   friscy-pack alpine:latest
#   friscy-pack myapp:riscv64 --output dist/
#   friscy-pack python:3.11-alpine --aot  # Use AOT compilation

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
RUNTIME_DIR="${SCRIPT_DIR}/../runtime"
FRISCY_WASM="${RUNTIME_DIR}/build/friscy.wasm"
FRISCY_JS="${RUNTIME_DIR}/build/friscy.js"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log()  { echo -e "${GREEN}[friscy-pack]${NC} $1"; }
warn() { echo -e "${YELLOW}[friscy-pack]${NC} $1"; }
err()  { echo -e "${RED}[friscy-pack]${NC} $1"; exit 1; }

# Parse arguments
IMAGE=""
OUTPUT_DIR="./friscy-bundle"
USE_AOT=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --output|-o)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --aot)
            USE_AOT=true
            shift
            ;;
        --help|-h)
            echo "Usage: friscy-pack <image> [--output <dir>] [--aot]"
            echo ""
            echo "Package a Docker container for browser execution via friscy."
            echo ""
            echo "Options:"
            echo "  --output, -o <dir>  Output directory (default: ./friscy-bundle)"
            echo "  --aot               Use AOT compilation (faster, experimental)"
            echo "  --help, -h          Show this help"
            exit 0
            ;;
        *)
            IMAGE="$1"
            shift
            ;;
    esac
done

if [[ -z "$IMAGE" ]]; then
    err "No image specified. Usage: friscy-pack <image>"
fi

# Check dependencies
command -v docker >/dev/null 2>&1 || err "docker is required"
command -v jq >/dev/null 2>&1 || err "jq is required (apt install jq)"

log "Packaging: $IMAGE"
log "Output: $OUTPUT_DIR"

# Create output directory
mkdir -p "$OUTPUT_DIR"

# =============================================================================
# Step 1: Check if image is RISC-V, if not build it
# =============================================================================
log "Checking image architecture..."

# Try to inspect the image
ARCH=$(docker inspect "$IMAGE" 2>/dev/null | jq -r '.[0].Architecture' || echo "")

if [[ "$ARCH" == "riscv64" ]]; then
    log "Image is already RISC-V 64-bit"
    RISCV_IMAGE="$IMAGE"
else
    log "Image is $ARCH, need to build for RISC-V..."

    # Check if we have a Dockerfile
    if [[ -f "Dockerfile" ]]; then
        RISCV_IMAGE="${IMAGE%:*}:riscv64"
        log "Building $RISCV_IMAGE from Dockerfile..."

        docker buildx build \
            --platform linux/riscv64 \
            --load \
            -t "$RISCV_IMAGE" \
            . || err "Failed to build RISC-V image"
    else
        # Try to pull multi-arch image
        RISCV_IMAGE="$IMAGE"
        log "Pulling $IMAGE for linux/riscv64..."
        docker pull --platform linux/riscv64 "$IMAGE" 2>/dev/null || \
            err "Image not available for RISC-V and no Dockerfile found"
    fi
fi

# =============================================================================
# Step 2: Extract container filesystem
# =============================================================================
log "Extracting rootfs..."

CONTAINER_NAME="friscy-temp-$$"
docker create --platform linux/riscv64 --name "$CONTAINER_NAME" "$RISCV_IMAGE" /bin/true >/dev/null

# Export filesystem
docker export "$CONTAINER_NAME" > "$OUTPUT_DIR/rootfs.tar"
log "Exported rootfs: $(du -h "$OUTPUT_DIR/rootfs.tar" | cut -f1)"

# Get container config
CONFIG=$(docker inspect "$CONTAINER_NAME")
ENTRYPOINT=$(echo "$CONFIG" | jq -r '.[0].Config.Entrypoint // empty | if type == "array" then .[] else . end')
CMD=$(echo "$CONFIG" | jq -r '.[0].Config.Cmd // empty | if type == "array" then .[] else . end')
WORKDIR=$(echo "$CONFIG" | jq -r '.[0].Config.WorkingDir // "/"')
ENV=$(echo "$CONFIG" | jq -r '.[0].Config.Env // [] | .[]')

# Cleanup
docker rm "$CONTAINER_NAME" >/dev/null

# Determine what to run
if [[ -n "$ENTRYPOINT" ]]; then
    RUN_CMD="$ENTRYPOINT $CMD"
elif [[ -n "$CMD" ]]; then
    RUN_CMD="$CMD"
else
    RUN_CMD="/bin/sh"
fi

log "Entrypoint: $RUN_CMD"
log "Workdir: $WORKDIR"

# =============================================================================
# Step 2.5: AOT Compilation (optional)
# =============================================================================
if [[ "$USE_AOT" == "true" ]]; then
    log "Running AOT compilation..."

    # Check for rv2wasm
    RV2WASM="${SCRIPT_DIR}/../aot/target/release/rv2wasm"
    if [[ ! -f "$RV2WASM" ]]; then
        RV2WASM="${SCRIPT_DIR}/../aot/target/debug/rv2wasm"
    fi

    if [[ ! -f "$RV2WASM" ]]; then
        warn "rv2wasm not found, attempting to build..."
        # Ensure cargo is findable (rustup installs to ~/.cargo/bin)
        [[ -d "$HOME/.cargo/bin" ]] && export PATH="$HOME/.cargo/bin:$PATH"
        if command -v cargo >/dev/null 2>&1; then
            (cd "${SCRIPT_DIR}/../aot" && cargo build --release) || {
                warn "Failed to build rv2wasm, skipping AOT"
                USE_AOT=false
            }
            RV2WASM="${SCRIPT_DIR}/../aot/target/release/rv2wasm"
        else
            warn "cargo not found, skipping AOT compilation"
            USE_AOT=false
        fi
    fi

    if [[ "$USE_AOT" == "true" && -f "$RV2WASM" ]]; then
        # Extract rootfs temporarily
        AOT_TMP=$(mktemp -d)
        tar -xf "$OUTPUT_DIR/rootfs.tar" -C "$AOT_TMP"

        # Find and compile RISC-V ELF binaries
        AOT_COUNT=0
        mkdir -p "$OUTPUT_DIR/aot"

        # Use process substitution to avoid subshell (so AOT_COUNT propagates)
        while read -r elf; do
            # Check if it's a RISC-V ELF (try file command, fallback to magic bytes)
            IS_RISCV=false
            if command -v file >/dev/null 2>&1; then
                if file "$elf" 2>/dev/null | grep -q "RISC-V"; then
                    IS_RISCV=true
                fi
            else
                # Fallback: check ELF magic (7f 45 4c 46) and e_machine=0xf3 (RISC-V)
                MAGIC=$(od -A n -t x1 -N 4 "$elf" 2>/dev/null | tr -d ' ')
                if [[ "$MAGIC" == "7f454c46" ]]; then
                    # e_machine is at offset 18 (2 bytes, little-endian)
                    EMACH=$(od -A n -t x1 -j 18 -N 2 "$elf" 2>/dev/null | tr -d ' ')
                    if [[ "$EMACH" == "f300" ]]; then
                        IS_RISCV=true
                    fi
                fi
            fi

            if [[ "$IS_RISCV" == "true" ]]; then
                REL_PATH="${elf#$AOT_TMP}"
                AOT_OUT="$OUTPUT_DIR/aot${REL_PATH}.wasm"
                mkdir -p "$(dirname "$AOT_OUT")"

                if "$RV2WASM" "$elf" -o "$AOT_OUT" 2>/dev/null; then
                    log "  AOT compiled: $REL_PATH"
                    AOT_COUNT=$((AOT_COUNT + 1))
                fi
            fi
        done < <(find "$AOT_TMP" -type f -executable 2>/dev/null)

        rm -rf "$AOT_TMP"
        log "AOT compilation complete: $AOT_COUNT binaries"
    fi
fi

# =============================================================================
# Step 3: Generate manifest
# =============================================================================
log "Generating manifest..."

AOT_JSON="[]"
if [[ "$USE_AOT" == "true" && -d "$OUTPUT_DIR/aot" ]]; then
    # Build JSON array of AOT-compiled files (relative paths)
    AOT_FILES=""
    while read -r wasm_file; do
        REL="${wasm_file#$OUTPUT_DIR/}"
        if [[ -n "$AOT_FILES" ]]; then
            AOT_FILES="$AOT_FILES, \"$REL\""
        else
            AOT_FILES="\"$REL\""
        fi
    done < <(find "$OUTPUT_DIR/aot" -name '*.wasm' -type f 2>/dev/null)
    if [[ -n "$AOT_FILES" ]]; then
        AOT_JSON="[$AOT_FILES]"
    fi
fi

cat > "$OUTPUT_DIR/manifest.json" << EOF
{
  "version": 1,
  "image": "$IMAGE",
  "entrypoint": "$(printf '%s' "$RUN_CMD")",
  "workdir": "$WORKDIR",
  "env": [
$(echo "$ENV" | sed 's/^/    "/; s/$/"/' | paste -sd ',' | sed 's/,/,\n/g')
  ],
  "aot": $AOT_JSON,
  "created": "$(date -Iseconds)"
}
EOF

# =============================================================================
# Step 4: Copy or build friscy runtime
# =============================================================================
if [[ -f "$FRISCY_WASM" ]]; then
    log "Copying pre-built friscy runtime..."
    cp "$FRISCY_WASM" "$OUTPUT_DIR/"
    cp "$FRISCY_JS" "$OUTPUT_DIR/"
else
    warn "Pre-built friscy not found, building..."
    (cd "$SCRIPT_DIR" && ./harness.sh) || err "Failed to build friscy"
    FRISCY_WASM="${RUNTIME_DIR}/build/friscy.wasm"
    FRISCY_JS="${RUNTIME_DIR}/build/friscy.js"
    cp "$FRISCY_WASM" "$OUTPUT_DIR/"
    cp "$FRISCY_JS" "$OUTPUT_DIR/"
fi

# =============================================================================
# Step 5: Generate Service Worker
# =============================================================================
log "Generating service-worker.js..."

cat > "$OUTPUT_DIR/service-worker.js" << 'SWEOF'
const CACHE_NAME = 'friscy-cache-v1'; // Tagged cache for versioning
const CACHE_ASSETS = [
  './', // Cache index.html
  './index.html',
  './friscy.js',
  './friscy.wasm',
  './rootfs.tar',
  './manifest.json',
  'https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css',
  'https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js',
  'https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js',
];

// Install event: cache assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('[Service Worker] Caching all assets');
        return cache.addAll(CACHE_ASSETS);
      })
      .catch(error => {
        console.error('[Service Worker] Caching failed:', error);
      })
  );
});

// Activate event: clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('[Service Worker] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Fetch event: serve from cache if available, otherwise fetch from network
self.addEventListener('fetch', (event) => {
  // Always go to network for friscy.js and friscy.wasm if they are not yet in cache
  // This is because friscy.js might be re-generated often during development
  // We want to serve friscy.js and friscy.wasm from cache only if they are already present
  // For other assets, use a cache-first strategy.
  const url = new URL(event.request.url);
  const isLocalAsset = url.origin === self.location.origin && ( // Use self.location.origin in SW
    url.pathname.endsWith('/friscy.js') ||
    url.pathname.endsWith('/friscy.wasm') ||
    url.pathname.endsWith('/rootfs.tar') ||
    url.pathname.endsWith('/manifest.json')
  );

  if (isLocalAsset) {
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        // Cache-first, but update cache from network in background
        const fetchAndCache = fetch(event.request).then((networkResponse) => {
          if (networkResponse.ok) {
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(event.request, networkResponse.clone());
            });
          }
          return networkResponse;
        }).catch(() => {
            // Network failed, return cached response if available
            return cachedResponse || new Response('Network request failed and no cache available', { status: 408, headers: { 'Content-Type': 'text/plain' } });
        });

        return cachedResponse || fetchAndCache;
      })
    );
  } else {
    // For all other requests (like CDN assets), use a cache-first strategy
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        return cachedResponse || fetch(event.request).then((networkResponse) => {
          // Cache successful responses
          if (networkResponse.ok) {
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(event.request, networkResponse.clone());
            });
          }
          return networkResponse;
        });
      })
    );
  }
});
SWEOF

# =============================================================================
# Step 6: Generate HTML
# =============================================================================
log "Generating index.html..."

cat > "$OUTPUT_DIR/index.html" << 'HTMLEOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>friscy container</title>
    <!-- Use CDN for xterm.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" integrity="sha256-i/y/4bWf2p+9R2x/m+Zt4k5x+g/3+t+y+z+l/w+q/0=" crossorigin="anonymous">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 1rem;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        h1 { font-size: 1.2rem; font-weight: 500; }
        .status { font-size: 0.85rem; color: #888; margin-top: 0.25rem; }
        #terminal-container {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent scrollbars from container itself */
        }
        #terminal {
            flex: 1;
            border-radius: 8px;
            overflow: hidden;
            display: flex; /* Ensure terminal content fills space */
        }
        .xterm-viewport {
             overflow-y: auto; /* Enable scroll for terminal content */
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 1.1rem;
            text-align: center;
        }
        .loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 1rem;
            flex-shrink: 0;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .terminal-actions button {
            background-color: #0f3460;
            color: #eee;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }
        .terminal-actions button:hover {
            background-color: #16213e;
        }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>friscy container</h1>
            <div class="status" id="status">Loading...</div>
        </div>
        <div class="terminal-actions">
            <button id="fit-button">Fit Terminal</button>
            <button id="reset-button">Reset</button>
        </div>
    </header>
    <div id="terminal-container">
        <div id="terminal" class="loading">Initializing container...</div>
    </div>

    <!-- Register service worker -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('Service Worker registration failed: ', registrationError);
                    });
            });
        }
    </script>

    <!-- Import xterm.js and addons as ES Modules from CDN -->
    <script type="module">
        import { Terminal } from 'https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js';
        import { FitAddon } from 'https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js';
        import createFriscy from './friscy.js';

        const statusEl = document.getElementById('status');
        const terminalEl = document.getElementById('terminal');

        let term, fitAddon, friscyModule;
        const inputBuffer = [];
        let machineRunning = false;
        let resumeScheduled = false;

        function updateTerminalSize() {
            if (friscyModule && term && fitAddon) {
                fitAddon.fit();
                friscyModule._termRows = term.rows;
                friscyModule._termCols = term.cols;
            }
        }

        // Resume the RISC-V machine when it's waiting for stdin.
        // Called on keyboard input and after callMain returns.
        function scheduleResume() {
            if (!machineRunning || resumeScheduled) return;
            const stopped = friscyModule._friscy_stopped;
            if (!stopped || !stopped()) return;

            resumeScheduled = true;
            setTimeout(() => {
                resumeScheduled = false;
                if (!machineRunning) return;

                friscyModule._friscy_resume();

                if (friscyModule._friscy_stopped()) {
                    // Still waiting for more stdin — resume again if buffer has data
                    if (inputBuffer.length > 0) scheduleResume();
                } else {
                    // Machine finished (guest called exit)
                    machineRunning = false;
                    term.writeln('\r\n\x1b[33mProcess exited\x1b[0m');
                    statusEl.textContent = 'Exited';
                }
            }, 5);
        }

        async function main() {
            statusEl.textContent = 'Loading manifest...';
            const manifest = await fetch('./manifest.json').then(r => r.json());
            statusEl.textContent = `Image: ${manifest.image}`;

            // Initialize xterm.js
            terminalEl.innerHTML = '';
            terminalEl.classList.remove('loading');

            term = new Terminal({
                cursorBlink: true,
                convertEol: true,
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#0d1117',
                    foreground: '#c9d1d9',
                    selectionBackground: '#00507a',
                    cursor: '#c9d1d9',
                    black: '#000000',
                    red: '#e06c75',
                    green: '#98c379',
                    yellow: '#e5c07b',
                    blue: '#61afef',
                    magenta: '#c678dd',
                    cyan: '#56b6c2',
                    white: '#ffffff',
                    brightBlack: '#5c6370',
                    brightRed: '#e06c75',
                    brightGreen: '#98c379',
                    brightYellow: '#e5c07b',
                    brightBlue: '#61afef',
                    brightMagenta: '#c678dd',
                    brightCyan: '#56b6c2',
                    brightWhite: '#ffffff',
                }
            });
            fitAddon = new FitAddon();
            term.loadAddon(fitAddon);
            term.open(terminalEl);
            updateTerminalSize();

            window.addEventListener('resize', updateTerminalSize);
            document.getElementById('fit-button').addEventListener('click', updateTerminalSize);

            term.writeln('\x1b[1;32mfriscy\x1b[0m - Container runtime in WebAssembly');
            term.writeln(`Loading ${manifest.image}...`);
            term.writeln('');

            // Load rootfs
            statusEl.textContent = 'Loading rootfs...';
            const rootfs = await fetch('./rootfs.tar').then(r => r.arrayBuffer());
            term.writeln(`Loaded rootfs: ${(rootfs.byteLength / 1024 / 1024).toFixed(1)} MB`);

            // Initialize friscy Wasm module
            statusEl.textContent = 'Initializing runtime...';
            friscyModule = await createFriscy({
                noInitialRun: true,
                print: (text) => term.writeln(text),
                printErr: (text) => term.writeln('\x1b[31m' + text + '\x1b[0m'),
                _stdinBuffer: inputBuffer,
                _stdinEOF: false,
                _termRows: term.rows,
                _termCols: term.cols,
                _termWrite: (text) => term.write(text),
            });

            // Load rootfs into Emscripten virtual FS
            friscyModule.FS.writeFile('/rootfs.tar', new Uint8Array(rootfs));

            // Wire keyboard → stdin buffer → machine resume
            term.onData((data) => {
                const bytes = new TextEncoder().encode(data);
                inputBuffer.push(...bytes);
                scheduleResume();
            });

            // Build args matching main.cpp: --rootfs <tar> <entry> [args...]
            const guestCmd = manifest.entrypoint.split(' ').filter(s => s);
            const args = ['--rootfs', '/rootfs.tar', ...guestCmd];

            statusEl.textContent = 'Running...';
            term.writeln('Starting: ' + manifest.entrypoint);
            term.writeln('\u2500'.repeat(40));

            // Run the container
            try {
                machineRunning = true;
                friscyModule.callMain(args);

                // If machine stopped for stdin, enter interactive mode
                if (friscyModule._friscy_stopped && friscyModule._friscy_stopped()) {
                    statusEl.textContent = 'Interactive';
                    scheduleResume();
                } else {
                    machineRunning = false;
                    term.writeln('\r\n\x1b[33mProcess exited\x1b[0m');
                    statusEl.textContent = 'Exited';
                }
            } catch (e) {
                machineRunning = false;
                term.writeln('\x1b[31mError: ' + e.message + '\x1b[0m');
                statusEl.textContent = 'Error';
                console.error(e);
            }
        }

        document.getElementById('reset-button').addEventListener('click', () => location.reload());

        main().catch(e => {
            console.error(e);
            statusEl.textContent = 'Error: ' + e.message;
        });
    </script>
</body>
</html>
HTMLEOF

# =============================================================================
# Step 6: Summary
# =============================================================================
echo ""
log "Bundle created successfully!"
echo ""
echo -e "  ${BLUE}Output directory:${NC} $OUTPUT_DIR"
echo ""
echo "  Files:"
ls -lh "$OUTPUT_DIR" | tail -n +2 | while read line; do
    echo "    $line"
done
echo ""
echo -e "  ${GREEN}To run locally:${NC}"
echo "    cd $OUTPUT_DIR && python3 -m http.server 8080"
echo "    # Then open http://localhost:8080"
echo ""
echo -e "  ${GREEN}To deploy:${NC}"
echo "    Upload contents of $OUTPUT_DIR to any static hosting"
echo ""
