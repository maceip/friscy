#!/bin/bash
#
# friscy-pack: Package Docker container for browser execution
#
# Usage:
#   friscy-pack <image> [--output <dir>] [--aot]
#
# Examples:
#   friscy-pack alpine:latest
#   friscy-pack myapp:riscv64 --output dist/
#   friscy-pack python:3.11-alpine --aot  # Use AOT compilation

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
RUNTIME_DIR="${SCRIPT_DIR}/../runtime"
FRISCY_WASM="${RUNTIME_DIR}/build/friscy.wasm"
FRISCY_JS="${RUNTIME_DIR}/build/friscy.js"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log()  { echo -e "${GREEN}[friscy-pack]${NC} $1"; }
warn() { echo -e "${YELLOW}[friscy-pack]${NC} $1"; }
err()  { echo -e "${RED}[friscy-pack]${NC} $1"; exit 1; }

# Parse arguments
IMAGE=""
OUTPUT_DIR="./friscy-bundle"
USE_AOT=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --output|-o)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --aot)
            USE_AOT=true
            shift
            ;;
        --help|-h)
            echo "Usage: friscy-pack <image> [--output <dir>] [--aot]"
            echo ""
            echo "Package a Docker container for browser execution via friscy."
            echo ""
            echo "Options:"
            echo "  --output, -o <dir>  Output directory (default: ./friscy-bundle)"
            echo "  --aot               Use AOT compilation (faster, experimental)"
            echo "  --help, -h          Show this help"
            exit 0
            ;;
        *)
            IMAGE="$1"
            shift
            ;;
    esac
done

if [[ -z "$IMAGE" ]]; then
    err "No image specified. Usage: friscy-pack <image>"
fi

# Check dependencies
command -v docker >/dev/null 2>&1 || err "docker is required"
command -v jq >/dev/null 2>&1 || err "jq is required (apt install jq)"

log "Packaging: $IMAGE"
log "Output: $OUTPUT_DIR"

# Create output directory
mkdir -p "$OUTPUT_DIR"

# =============================================================================
# Step 1: Check if image is RISC-V, if not build it
# =============================================================================
log "Checking image architecture..."

# Try to inspect the image
ARCH=$(docker inspect "$IMAGE" 2>/dev/null | jq -r '.[0].Architecture' || echo "")

if [[ "$ARCH" == "riscv64" ]]; then
    log "Image is already RISC-V 64-bit"
    RISCV_IMAGE="$IMAGE"
else
    log "Image is $ARCH, need to build for RISC-V..."

    # Check if we have a Dockerfile
    if [[ -f "Dockerfile" ]]; then
        RISCV_IMAGE="${IMAGE%:*}:riscv64"
        log "Building $RISCV_IMAGE from Dockerfile..."

        docker buildx build \
            --platform linux/riscv64 \
            --load \
            -t "$RISCV_IMAGE" \
            . || err "Failed to build RISC-V image"
    else
        # Try to pull multi-arch image
        RISCV_IMAGE="$IMAGE"
        log "Pulling $IMAGE for linux/riscv64..."
        docker pull --platform linux/riscv64 "$IMAGE" 2>/dev/null || \
            err "Image not available for RISC-V and no Dockerfile found"
    fi
fi

# =============================================================================
# Step 2: Extract container filesystem
# =============================================================================
log "Extracting rootfs..."

CONTAINER_NAME="friscy-temp-$$"
docker create --platform linux/riscv64 --name "$CONTAINER_NAME" "$RISCV_IMAGE" /bin/true >/dev/null

# Export filesystem
docker export "$CONTAINER_NAME" > "$OUTPUT_DIR/rootfs.tar"
log "Exported rootfs: $(du -h "$OUTPUT_DIR/rootfs.tar" | cut -f1)"

# Get container config
CONFIG=$(docker inspect "$CONTAINER_NAME")
ENTRYPOINT=$(echo "$CONFIG" | jq -r '.[0].Config.Entrypoint // empty | if type == "array" then .[] else . end')
CMD=$(echo "$CONFIG" | jq -r '.[0].Config.Cmd // empty | if type == "array" then .[] else . end')
WORKDIR=$(echo "$CONFIG" | jq -r '.[0].Config.WorkingDir // "/"')
ENV=$(echo "$CONFIG" | jq -r '.[0].Config.Env // [] | .[]')

# Cleanup
docker rm "$CONTAINER_NAME" >/dev/null

# Determine what to run
if [[ -n "$ENTRYPOINT" ]]; then
    RUN_CMD="$ENTRYPOINT $CMD"
elif [[ -n "$CMD" ]]; then
    RUN_CMD="$CMD"
else
    RUN_CMD="/bin/sh"
fi

log "Entrypoint: $RUN_CMD"
log "Workdir: $WORKDIR"

# =============================================================================
# Step 2.5: AOT Compilation (optional)
# =============================================================================
if [[ "$USE_AOT" == "true" ]]; then
    log "Running AOT compilation..."

    # Check for rv2wasm
    RV2WASM="${SCRIPT_DIR}/../aot/target/release/rv2wasm"
    if [[ ! -f "$RV2WASM" ]]; then
        RV2WASM="${SCRIPT_DIR}/../aot/target/debug/rv2wasm"
    fi

    if [[ ! -f "$RV2WASM" ]]; then
        warn "rv2wasm not found, attempting to build..."
        # Ensure cargo is findable (rustup installs to ~/.cargo/bin)
        [[ -d "$HOME/.cargo/bin" ]] && export PATH="$HOME/.cargo/bin:$PATH"
        if command -v cargo >/dev/null 2>&1; then
            (cd "${SCRIPT_DIR}/../aot" && cargo build --release) || {
                warn "Failed to build rv2wasm, skipping AOT"
                USE_AOT=false
            }
            RV2WASM="${SCRIPT_DIR}/../aot/target/release/rv2wasm"
        else
            warn "cargo not found, skipping AOT compilation"
            USE_AOT=false
        fi
    fi

    if [[ "$USE_AOT" == "true" && -f "$RV2WASM" ]]; then
        # Extract rootfs temporarily
        AOT_TMP=$(mktemp -d)
        tar -xf "$OUTPUT_DIR/rootfs.tar" -C "$AOT_TMP"

        # Find and compile RISC-V ELF binaries
        AOT_COUNT=0
        mkdir -p "$OUTPUT_DIR/aot"

        # Use process substitution to avoid subshell (so AOT_COUNT propagates)
        while read -r elf; do
            # Check if it's a RISC-V ELF (try file command, fallback to magic bytes)
            IS_RISCV=false
            if command -v file >/dev/null 2>&1; then
                if file "$elf" 2>/dev/null | grep -q "RISC-V"; then
                    IS_RISCV=true
                fi
            else
                # Fallback: check ELF magic (7f 45 4c 46) and e_machine=0xf3 (RISC-V)
                MAGIC=$(od -A n -t x1 -N 4 "$elf" 2>/dev/null | tr -d ' ')
                if [[ "$MAGIC" == "7f454c46" ]]; then
                    # e_machine is at offset 18 (2 bytes, little-endian)
                    EMACH=$(od -A n -t x1 -j 18 -N 2 "$elf" 2>/dev/null | tr -d ' ')
                    if [[ "$EMACH" == "f300" ]]; then
                        IS_RISCV=true
                    fi
                fi
            fi

            if [[ "$IS_RISCV" == "true" ]]; then
                REL_PATH="${elf#$AOT_TMP}"
                AOT_OUT="$OUTPUT_DIR/aot${REL_PATH}.wasm"
                mkdir -p "$(dirname "$AOT_OUT")"

                if "$RV2WASM" "$elf" -o "$AOT_OUT" 2>/dev/null; then
                    log "  AOT compiled: $REL_PATH"
                    AOT_COUNT=$((AOT_COUNT + 1))
                fi
            fi
        done < <(find "$AOT_TMP" -type f -executable 2>/dev/null)

        rm -rf "$AOT_TMP"
        log "AOT compilation complete: $AOT_COUNT binaries"
    fi
fi

# =============================================================================
# Step 3: Generate manifest
# =============================================================================
log "Generating manifest..."

AOT_JSON="[]"
if [[ "$USE_AOT" == "true" && -d "$OUTPUT_DIR/aot" ]]; then
    # Build JSON array of AOT-compiled files (relative paths)
    AOT_FILES=""
    while read -r wasm_file; do
        REL="${wasm_file#$OUTPUT_DIR/}"
        if [[ -n "$AOT_FILES" ]]; then
            AOT_FILES="$AOT_FILES, \"$REL\""
        else
            AOT_FILES="\"$REL\""
        fi
    done < <(find "$OUTPUT_DIR/aot" -name '*.wasm' -type f 2>/dev/null)
    if [[ -n "$AOT_FILES" ]]; then
        AOT_JSON="[$AOT_FILES]"
    fi
fi

cat > "$OUTPUT_DIR/manifest.json" << EOF
{
  "version": 1,
  "image": "$IMAGE",
  "entrypoint": "$(printf '%s' "$RUN_CMD")",
  "workdir": "$WORKDIR",
  "env": [
$(echo "$ENV" | sed 's/^/    "/; s/$/"/' | paste -sd ',' | sed 's/,/,\n/g')
  ],
  "aot": $AOT_JSON,
  "created": "$(date -Iseconds)"
}
EOF

# =============================================================================
# Step 4: Copy or build friscy runtime
# =============================================================================
if [[ -f "$FRISCY_WASM" ]]; then
    log "Copying pre-built friscy runtime..."
    cp "$FRISCY_WASM" "$OUTPUT_DIR/"
    cp "$FRISCY_JS" "$OUTPUT_DIR/"
else
    warn "Pre-built friscy not found, building..."
    (cd "$SCRIPT_DIR" && ./harness.sh) || err "Failed to build friscy"
    FRISCY_WASM="${RUNTIME_DIR}/build/friscy.wasm"
    FRISCY_JS="${RUNTIME_DIR}/build/friscy.js"
    cp "$FRISCY_WASM" "$OUTPUT_DIR/"
    cp "$FRISCY_JS" "$OUTPUT_DIR/"
fi

# =============================================================================
# Step 5: Generate Service Worker
# =============================================================================
log "Generating service-worker.js..."

cat > "$OUTPUT_DIR/service-worker.js" << 'SWEOF'
const CACHE_NAME = 'friscy-cache-v1'; // Tagged cache for versioning
const CACHE_ASSETS = [
  './', // Cache index.html
  './index.html',
  './friscy.js',
  './friscy.wasm',
  './rootfs.tar',
  './manifest.json',
  'https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css',
  'https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js',
  'https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js',
];

// Install event: cache assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then((cache) => {
        console.log('[Service Worker] Caching all assets');
        return cache.addAll(CACHE_ASSETS);
      })
      .catch(error => {
        console.error('[Service Worker] Caching failed:', error);
      })
  );
});

// Activate event: clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log('[Service Worker] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Fetch event: serve from cache if available, otherwise fetch from network
self.addEventListener('fetch', (event) => {
  // Always go to network for friscy.js and friscy.wasm if they are not yet in cache
  // This is because friscy.js might be re-generated often during development
  // We want to serve friscy.js and friscy.wasm from cache only if they are already present
  // For other assets, use a cache-first strategy.
  const url = new URL(event.request.url);
  const isLocalAsset = url.origin === self.location.origin && ( // Use self.location.origin in SW
    url.pathname.endsWith('/friscy.js') ||
    url.pathname.endsWith('/friscy.wasm') ||
    url.pathname.endsWith('/rootfs.tar') ||
    url.pathname.endsWith('/manifest.json')
  );

  if (isLocalAsset) {
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        // Cache-first, but update cache from network in background
        const fetchAndCache = fetch(event.request).then((networkResponse) => {
          if (networkResponse.ok) {
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(event.request, networkResponse.clone());
            });
          }
          return networkResponse;
        }).catch(() => {
            // Network failed, return cached response if available
            return cachedResponse || new Response('Network request failed and no cache available', { status: 408, headers: { 'Content-Type': 'text/plain' } });
        });

        return cachedResponse || fetchAndCache;
      })
    );
  } else {
    // For all other requests (like CDN assets), use a cache-first strategy
    event.respondWith(
      caches.match(event.request).then((cachedResponse) => {
        return cachedResponse || fetch(event.request).then((networkResponse) => {
          // Cache successful responses
          if (networkResponse.ok) {
            caches.open(CACHE_NAME).then((cache) => {
              cache.put(event.request, networkResponse.clone());
            });
          }
          return networkResponse;
        });
      })
    );
  }
});
SWEOF

# =============================================================================
# Step 6: Generate HTML
# =============================================================================
log "Generating index.html..."

cat > "$OUTPUT_DIR/index.html" << 'HTMLEOF'
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>friscy container</title>
    <!-- Use CDN for xterm.js CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" integrity="sha256-i/y/4bWf2p+9R2x/m+Zt4k5x+g/3+t+y+z+l/w+q/0=" crossorigin="anonymous">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 1rem;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        h1 { font-size: 1.2rem; font-weight: 500; }
        .status { font-size: 0.85rem; color: #888; margin-top: 0.25rem; }
        #terminal-container {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent scrollbars from container itself */
        }
        #terminal {
            flex: 1;
            border-radius: 8px;
            overflow: hidden;
            display: flex; /* Ensure terminal content fills space */
        }
        .xterm-viewport {
             overflow-y: auto; /* Enable scroll for terminal content */
        }
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            font-size: 1.1rem;
            text-align: center;
        }
        .loading::after {
            content: '';
            width: 20px;
            height: 20px;
            border: 2px solid #fff;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 1rem;
            flex-shrink: 0;
        }
        @keyframes spin { to { transform: rotate(360deg); } }

        .terminal-actions button {
            background-color: #0f3460;
            color: #eee;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-left: 0.5rem;
        }
        .terminal-actions button:hover {
            background-color: #16213e;
        }
    </style>
</head>
<body>
    <header>
        <div>
            <h1>friscy container</h1>
            <div class="status" id="status">Loading...</div>
        </div>
        <div class="terminal-actions">
            <button id="fit-button">Fit Terminal</button>
            <button id="reset-button">Reset</button>
        </div>
    </header>
    <div id="terminal-container">
        <div id="terminal" class="loading">Initializing container...</div>
    </div>

    <!-- Register service worker -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered: ', registration);
                    })
                    .catch(registrationError => {
                        console.log('Service Worker registration failed: ', registrationError);
                    });
            });
        }
    </script>

    <!-- Import xterm.js and addons as ES Modules from CDN -->
    <script type="module">
        import { Terminal } from 'https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js';
        import { FitAddon } from 'https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js';
        import createFriscy from './friscy.js';

        const statusEl = document.getElementById('status');
        const terminalEl = document.getElementById('terminal');

        let term;
        let fitAddon;
        let friscyModule; // Renamed from Module to avoid conflicts
        let inputBuffer = [];
        let inputWaitingResolve = null; // Promise resolver for blocking stdin

        // Helper to update terminal dimensions on the Module object for C++
        function updateTerminalSize() {
            if (friscyModule && term && fitAddon) {
                fitAddon.fit();
                friscyModule._termRows = term.rows;
                friscyModule._termCols = term.cols;
            }
        }

        async function main() {
            statusEl.textContent = 'Loading manifest...';

            // Load manifest
            const manifest = await fetch('./manifest.json').then(r => r.json());
            statusEl.textContent = `Image: ${manifest.image}`;

            // Initialize terminal
            terminalEl.innerHTML = '';
            terminalEl.classList.remove('loading');

            term = new Terminal({
                cursorBlink: true,
                convertEol: true, // Convert LF to CRLF
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#0d1117',
                    foreground: '#c9d1d9',
                    selectionBackground: '#00507a',
                    cursor: '#c9d1d9',
                    black: '#000000',
                    red: '#e06c75',
                    green: '#98c379',
                    yellow: '#e5c07b',
                    blue: '#61afef',
                    magenta: '#c678dd',
                    cyan: '#56b6c2',
                    white: '#ffffff',
                    brightBlack: '#5c6370',
                    brightRed: '#e06c75',
                    brightGreen: '#98c379',
                    brightYellow: '#e5c07b',
                    brightBlue: '#61afef',
                    brightMagenta: '#c678dd',
                    brightCyan: '#56b6c2',
                    brightWhite: '#ffffff',
                }
            });
            fitAddon = new FitAddon();
            term.loadAddon(fitAddon);
            term.open(terminalEl);
            updateTerminalSize(); // Initial fit

            window.addEventListener('resize', updateTerminalSize);
            document.getElementById('fit-button').addEventListener('click', updateTerminalSize);

            term.writeln('\x1b[1;32mfriscy\x1b[0m - Container runtime in WebAssembly');
            term.writeln(`Loading ${manifest.image}...`);
            term.writeln('');

            // Load rootfs
            statusEl.textContent = 'Loading rootfs...';
            const rootfs = await fetch('./rootfs.tar').then(r => r.arrayBuffer());
            term.writeln(`Loaded rootfs: ${(rootfs.byteLength / 1024 / 1024).toFixed(1)} MB`);

            // Initialize friscy Emscripten Module
            statusEl.textContent = 'Initializing runtime...';
            friscyModule = await createFriscy({
                // Emscripten's default output functions
                print: (text) => term.writeln(text),
                printErr: (text) => term.writeln('\x1b[31m' + text + '\x1b[0m'),

                // Custom stdin/stdout/stderr for C++ syscalls.hpp
                // These are called from EM_ASM blocks in C++
                _stdinBuffer: inputBuffer, // Expose for C++ to read
                _termRows: term.rows,
                _termCols: term.cols,
                _termWrite: (text) => term.write(text), // Raw write, not writeln
            });

            // Load rootfs into virtual filesystem
            const rootfsData = new Uint8Array(rootfs);
            friscyModule.FS.writeFile('/rootfs.tar', rootfsData);

            // Set up stdin from terminal
            term.onData((data) => {
                const bytes = new TextEncoder().encode(data);
                inputBuffer.push(...bytes);
                if (inputWaitingResolve) {
                    inputWaitingResolve();
                    inputWaitingResolve = null;
                }
            });

            // Handle blocking stdin from C++
            // This function will be called from C++ EM_ASM when stdin is empty
            friscyModule._readStdin = async () => {
                if (inputBuffer.length === 0) {
                    await new Promise(resolve => { inputWaitingResolve = resolve; });
                }
                const charCode = inputBuffer.shift();
                return charCode !== undefined ? charCode : -1; // -1 for EOF, or actual char code
            };

            statusEl.textContent = 'Running...';
            term.writeln('Starting: ' + manifest.entrypoint);
            term.writeln('â”€'.repeat(40));

            // Run the container
            try {
                // Determine argv: entrypoint + manifest.env + manifest.cmd
                // Emscripten Module.callMain expects:
                // argv[0] = entrypoint
                // argv[1..N] = args
                const argv = [manifest.entrypoint];
                // Assuming manifest.entrypoint might be an array, or a single string
                // The current friscy-pack manifest.entrypoint is a single string.
                // The C++ main uses entry_path, and then adds guest_args.
                // Need to reconcile how args are passed.

                // For simplicity, let's assume the manifest entrypoint is the full command.
                // The original harness.sh passes:
                // Module.callMain(['--rootfs', '/rootfs.tar', '--', manifest.entrypoint]);
                // This means the C++ main() gets argv like:
                // ['./friscy', '--rootfs', '/rootfs.tar', '--', '/bin/sh']
                // The actual guest_args will be: ['/bin/sh']

                // Let's adapt this.
                const guestArgv = [manifest.entrypoint, ...manifest.env.map(e => `--env=${e}`)]; // Simplified for now
                // This might need more careful parsing of manifest.entrypoint and manifest.cmd
                // For now, let's use what Workstream D's problem section implies:
                // "Starting: /bin/sh"
                // So the target is just /bin/sh.

                // Re-evaluate the arguments for Module.callMain
                // It should be what the RISC-V guest receives.
                // The `main.cpp` currently constructs `guest_args` for the RISC-V guest.
                // So, the `Module.callMain` should ideally be called with:
                // `Module.callMain(guest_args_for_wasm)`
                // Where `guest_args_for_wasm` should mirror `guest_args` in `main.cpp`.
                // For now, let's use a simplified approach as in the current `friscy-pack`.

                // Original: Module.callMain([
                //     '--rootfs', '/rootfs.tar',
                //     '--', manifest.entrypoint
                // ]);
                // This implies that main.cpp parses its own arguments.
                // The C++ `main` function is essentially the entry point of the compiled Wasm.
                // It receives `argc` and `argv`. So `Module.callMain` parameters are `argv` for C++ main.
                // My C++ `main.cpp` expects its own arguments, then the guest arguments after `--`.

                const emscriptenArgs = [
                    'friscy.wasm', // Conventionally, argv[0] is program name
                    '--rootfs', '/rootfs.tar',
                    '--',
                    manifest.entrypoint, // This is the actual entrypoint for the guest
                    // ... any args for manifest.entrypoint would go here
                ];
                // For now, assume manifest.entrypoint includes everything needed.
                // If manifest.entrypoint is "/bin/sh -c 'ls /'", it needs to be parsed.
                // Current manifest.json sets "entrypoint": "/bin/sh".
                // So, we need the arguments that the original container would run.
                // The current `friscy-pack` script uses `RUN_CMD` which combines ENTRYPOINT and CMD.
                // Let's pass that to the C++ main after `--`.
                // `manifest.entrypoint` is "$RUN_CMD" from friscy-pack.

                const guestCmd = manifest.entrypoint.split(' ').filter(arg => arg.length > 0);
                const fullEmscriptenArgs = ['friscy.wasm', '--rootfs', '/rootfs.tar', '--', ...guestCmd];

                const exitCode = friscyModule.callMain(fullEmscriptenArgs);
                term.writeln('');
                term.writeln(`\x1b[33mProcess exited with code ${exitCode}\x1b[0m`);
                statusEl.textContent = `Exited (${exitCode})`;
            } catch (e) {
                term.writeln('\x1b[31mError: ' + e.message + '\x1b[0m');
                statusEl.textContent = 'Error';
            }
        }

        document.getElementById('reset-button').addEventListener('click', () => {
            // Simple reset: reload the page
            location.reload();
        });

        main().catch(e => {
            console.error(e);
            statusEl.textContent = 'Error: ' + e.message;
            term.writeln('\x1b[31mFATAL ERROR: ' + e.message + '\x1b[0m');
        });
    </script>
</body>
</html>
HTMLEOF

# =============================================================================
# Step 6: Summary
# =============================================================================
echo ""
log "Bundle created successfully!"
echo ""
echo -e "  ${BLUE}Output directory:${NC} $OUTPUT_DIR"
echo ""
echo "  Files:"
ls -lh "$OUTPUT_DIR" | tail -n +2 | while read line; do
    echo "    $line"
done
echo ""
echo -e "  ${GREEN}To run locally:${NC}"
echo "    cd $OUTPUT_DIR && python3 -m http.server 8080"
echo "    # Then open http://localhost:8080"
echo ""
echo -e "  ${GREEN}To deploy:${NC}"
echo "    Upload contents of $OUTPUT_DIR to any static hosting"
echo ""
