<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>friscy</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #1a1a2e;
            color: #eee;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        header {
            padding: 1rem;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        h1 { font-size: 1.2rem; font-weight: 500; }
        .status { font-size: 0.85rem; color: #888; margin-top: 0.25rem; }
        .net-status {
            font-size: 0.75rem;
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            margin-left: 0.5rem;
        }
        .net-status.connected { background: #1a4d2e; color: #98c379; }
        .net-status.disconnected { background: #4d1a1a; color: #e06c75; }
        .net-status.connecting { background: #4d3d1a; color: #e5c07b; }
        #terminal-container {
            flex: 1;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #terminal {
            flex: 1;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
        }
        .xterm .xterm-viewport {
            overflow-y: hidden !important;
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }
        .xterm .xterm-viewport::-webkit-scrollbar {
            width: 0 !important;
            height: 0 !important;
            display: none !important;
        }
        #terminal::-webkit-scrollbar,
        #terminal-wrapper::-webkit-scrollbar {
            display: none !important;
        }
        #terminal, #terminal-wrapper, .xterm-screen {
            scrollbar-width: none !important;
            -ms-overflow-style: none !important;
        }
        .xterm-screen::-webkit-scrollbar {
            display: none !important;
        }
        /* Progress overlay */
        #progress-overlay {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            gap: 1.5rem;
            background: #0d1117;
            border-radius: 8px;
        }
        #progress-overlay.hidden { display: none; }
        .progress-title {
            font-size: 1.4rem;
            font-weight: 600;
            letter-spacing: -0.02em;
        }
        .progress-stage {
            font-size: 0.9rem;
            color: #8b949e;
        }
        .progress-wave {
            width: min(400px, 80%);
            height: 24px;
        }
        .progress-detail {
            font-size: 0.8rem;
            color: #484f58;
            font-variant-numeric: tabular-nums;
        }

        /* Import panel */
        #import-panel {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            background: #0d1117;
            border-radius: 8px;
            gap: 0;
            padding: 2rem;
        }
        #import-panel.visible { display: flex; }
        .import-title {
            font-size: 1.1rem;
            color: #e6edf3;
            font-weight: 500;
            margin-bottom: 4px;
        }
        .import-subtitle {
            font-size: 0.8rem;
            color: #6e7681;
            margin-bottom: 12px;
        }
        .import-chip {
            display: inline-block;
            background: transparent;
            color: #f9a8d4;
            padding: 4px 12px;
            border-radius: 999px;
            border: 1px solid #f9a8d4;
            font-size: 0.8rem;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            cursor: pointer;
            transition: opacity 0.15s, border-color 0.15s;
            margin-bottom: 4px;
            transform: translateX(-45px);
        }
        .import-chip:hover { border-color: #fbcfe8; color: #fbcfe8; }
        .import-chip.hidden { opacity: 0; pointer-events: none; }
        .import-input-wrapper {
            position: relative;
            width: min(720px, 90%);
            display: flex;
            align-items: stretch;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 999px;
            transition: border-color 0.15s;
        }
        .import-input-wrapper:focus-within { border-color: #58a6ff; }
        .import-input {
            flex: 1;
            padding: 6px 20px;
            background: transparent;
            border: none;
            color: #e6edf3;
            font-size: 0.95rem;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            outline: none;
            min-width: 0;
        }
        .import-input::placeholder { color: #484f58; }
        .import-go-btn {
            padding: 0 8px 0 4px;
            background: #238636;
            color: #fff;
            border: none;
            border-left: 1px solid #30363d;
            border-radius: 0 999px 999px 0;
            font-size: 0.85rem;
            font-family: inherit;
            cursor: pointer;
            transition: background 0.15s;
            white-space: nowrap;
            flex-shrink: 0;
        }
        .import-go-btn:hover { background: #2ea043; }
        .import-go-btn:disabled { background: #21262d; color: #484f58; cursor: default; }
        .import-autocomplete {
            position: absolute;
            top: calc(100% + 4px);
            left: 0;
            right: 0;
            max-height: 240px;
            overflow-y: auto;
            background: #161b22;
            border: 1px solid #30363d;
            border-radius: 12px;
            z-index: 50;
            display: none;
        }
        .import-autocomplete.open { display: block; }
        .import-ac-item {
            padding: 8px 20px;
            cursor: pointer;
            font-size: 0.85rem;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            color: #c9d1d9;
            border-bottom: 1px solid #21262d;
        }
        .import-ac-item:first-child { border-radius: 12px 12px 0 0; }
        .import-ac-item:last-child { border-bottom: none; border-radius: 0 0 12px 12px; }
        .import-ac-item:only-child { border-radius: 12px; }
        .import-ac-item:hover, .import-ac-item.selected {
            background: #1f6feb22;
            color: #58a6ff;
        }
        .import-ac-item .match { color: #58a6ff; font-weight: 600; }
        .import-status {
            font-size: 0.8rem;
            color: #8b949e;
            min-height: 1.2em;
        }
        .import-progress-canvas {
            width: min(460px, 90%);
            height: 18px;
            display: none;
        }
        .import-progress-canvas.visible { display: block;
        }

        .header-link {
            color: inherit;
            text-decoration: none;
        }
        .header-link:hover { text-decoration: underline; }
        .header-logo {
            height: 24px;
            opacity: 0.7;
            margin-left: 1rem;
        }
        .header-logo:hover { opacity: 1; }
        /* Mobile breakpoints */
        @media (max-width: 768px) {
            header { padding: 0.5rem 0.75rem; }
            h1 { font-size: 1rem; }
            .status { font-size: 0.75rem; }
            .header-logo { height: 18px; margin-left: 0.5rem; }
            .tab-bar { padding: 0 0.5rem; gap: 1px; overflow-x: auto; scrollbar-width: none; }
            .tab-bar::-webkit-scrollbar { display: none; }
            .tab { padding: 5px 8px; font-size: 0.7rem; gap: 4px; white-space: nowrap; }
            .tab-icon { width: 13px; height: 13px; }
            .tab-strip-border { margin: 0 0.5rem; }
            #terminal-container { padding: 0.5rem; }
            #reset-btn { width: 24px; height: 24px; font-size: 0.9rem; line-height: 22px; }
            .import-input-wrapper { width: 95%; }
            .import-title { font-size: 0.95rem; }
            .import-input { font-size: 0.85rem; padding: 8px 10px; }
        }
        @media (max-width: 480px) {
            header { padding: 0.4rem 0.5rem; }
            h1 { font-size: 0.9rem; }
            .status { font-size: 0.7rem; margin-top: 0.15rem; }
            .net-status { font-size: 0.65rem; padding: 0.15rem 0.35rem; }
            .tab { padding: 4px 6px; font-size: 0.65rem; }
            .tab-icon { width: 12px; height: 12px; }
            #terminal-container { padding: 0.25rem; }
        }
        /* IME-aware: when virtual keyboard is visible, shrink terminal */
        @media (max-height: 450px) {
            header { padding: 0.25rem 0.5rem; }
            h1 { font-size: 0.85rem; }
            .status { display: none; }
            .tab-bar { padding: 0 0.25rem; }
            .tab { padding: 3px 5px; font-size: 0.6rem; }
            #terminal-container { padding: 0.25rem; }
        }
        .tab-bar {
            display: flex;
            padding: 0 1rem;
            padding-top: 0.4rem;
            gap: 2px;
            align-items: flex-end;
        }
        .tab {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            background: #0a0e14;
            color: #6e7681;
            border: 1px solid #21262d;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 0.8rem;
            font-family: inherit;
            position: relative;
            bottom: -1px;
            transition: background 0.2s, color 0.2s;
        }
        .tab:hover { background: #161b22; color: #c9d1d9; }
        .tab.active {
            background: #0d1117;
            color: #e6edf3;
            border-color: #30363d;
            z-index: 1;
        }
        .tab-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }
        .tab-strip-border {
            height: 0;
            border-bottom: 1px solid #30363d;
            margin: 0 1rem;
        }
        #terminal-wrapper {
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #reset-btn {
            display: none;
            position: absolute;
            top: 6px;
            right: 6px;
            z-index: 100;
            background: rgba(15, 52, 96, 0.75);
            color: #8b949e;
            border: 1px solid rgba(48, 54, 61, 0.5);
            border-radius: 4px;
            width: 28px;
            height: 28px;
            cursor: pointer;
            font-size: 1.1rem;
            line-height: 26px;
            text-align: center;
            padding: 0;
            backdrop-filter: blur(4px);
            transition: background 0.15s, color 0.15s;
        }
        #reset-btn:hover { background: rgba(15, 52, 96, 0.95); color: #eee; }
    </style>
</head>
<body>
    <header>
        <div>
            <h1><a href="https://github.com/maceip/friscy" class="header-link">friscy</a></h1>
            <div class="status" id="status">fast risc-v runtime for the browser &amp; wasm<span id="net-status" class="net-status disconnected">net: off</span></div>
        </div>
        <div style="display:flex;align-items:center;gap:0.5rem;">
            <img src="./webmcp-icon.svg" alt="WebMCP" class="header-logo" title="WebMCP enabled">
            <img src="./riscv-logo.jpg" alt="RISC-V" class="header-logo">
        </div>
    </header>
    <div class="tab-bar">
        <button class="tab active" id="tab-alpine" data-example="alpine" title="Alpine Linux shell">
            <img src="./alpine-icon.svg" alt="" class="tab-icon">Alpine
        </button>
        <button class="tab" id="tab-nodejs" data-example="nodejs" title="Interactive Node.js REPL">
            <img src="./nodejs-icon.svg" alt="" class="tab-icon">Node.js
        </button>
        <button class="tab" id="tab-server" data-example="server" title="HTTP echo server on port 8080">
            <img src="./go-icon.svg" alt="" class="tab-icon">Go Server
        </button>
        <button class="tab" id="tab-import" data-example="import" title="Import a Docker image">
            <img src="./docker-icon.svg" alt="" class="tab-icon">Import
        </button>
    </div>
    <div class="tab-strip-border"></div>
    <div id="terminal-container">
        <div id="progress-overlay">
            <div class="progress-title">friscy</div>
            <div class="progress-stage" id="progress-stage">Preparing...</div>
            <canvas id="progress-canvas" class="progress-wave" width="800" height="48"></canvas>
            <div class="progress-detail" id="progress-detail">&nbsp;</div>
        </div>
        <div id="import-panel">
            <div class="import-title">Import a Docker image</div>
            <div class="import-subtitle">Pull any public image from Docker Hub and run it in friscy</div>
            <div class="import-chip" id="import-chip">ubuntu:latest</div>
            <form id="import-form" toolname="import_docker_image" tooldescription="Pull a Docker image from Docker Hub and run it in a RISC-V emulator in the browser">
            <div class="import-input-wrapper">
                <input type="text" class="import-input" id="import-input" name="image" placeholder="nginx:alpine" autocomplete="off" spellcheck="false" toolparamdescription="Docker image reference, e.g. ubuntu:latest or python:3.12">
                <button type="submit" class="import-go-btn" id="import-go-btn">Pull &amp; Run</button>
                <div class="import-autocomplete" id="import-ac"></div>
            </div>
            </form>
            <canvas class="import-progress-canvas" id="import-progress-canvas" width="460" height="18"></canvas>
            <div class="import-status" id="import-status">&nbsp;</div>
        </div>
        <div id="terminal-wrapper">
            <button id="reset-btn" title="Reset">&#x21bb;</button>
            <div id="terminal" style="display:none;"></div>
        </div>
    </div>

    <!-- Service worker: caching + COOP/COEP for cross-origin isolation -->
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./service-worker.js').then(reg => {
                console.log('Service Worker registered:', reg);
                // Reload when not yet isolated (first visit)
                if (!crossOriginIsolated && reg.active) {
                    location.reload();
                    return;
                }
                // Reload when a NEW service worker activates (cache update)
                reg.addEventListener('updatefound', () => {
                    const sw = reg.installing;
                    sw.addEventListener('statechange', () => {
                        if (sw.state === 'activated') {
                            console.log('New service worker activated, reloading...');
                            location.reload();
                        }
                    });
                });
            }).catch(e => console.error('Service Worker registration failed:', e));
        }
    </script>

    <!-- Import xterm.js and addons as ES Modules from CDN -->
    <script type="module">
        import { Terminal } from 'https://cdn.jsdelivr.net/npm/xterm@5.3.0/+esm';
        import { FitAddon } from 'https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/+esm';
        import { FriscyNetworkBridge } from './network_bridge.js';
        import { NetworkRPCHost } from './network_rpc_host.js';

        const statusEl = document.getElementById('status');
        const netStatusEl = document.getElementById('net-status');
        const terminalEl = document.getElementById('terminal');

        let term, fitAddon;
        let worker = null;
        let netBridge = null;
        let netRPCHost = null;
        let machineRunning = false;

        // SharedArrayBuffers for Worker communication
        let controlSab = null;
        let stdoutSab = null;
        let netSab = null;
        let controlView = null;
        let stdoutView = null;
        let stdoutBytes = null;

        const RING_HEADER = 8;
        const RING_SIZE = 65528;
        const CMD_IDLE = 0;
        const CMD_STDIN_REQUEST = 2;
        const CMD_STDIN_READY = 3;
        const CMD_EXIT = 4;

        // Pending stdin bytes from terminal input
        const stdinQueue = [];

        // Expose for testing (Puppeteer)
        window._friscyStdinQueue = stdinQueue;

        function updateNetStatus(state) {
            netStatusEl.className = 'net-status ' + state;
            const labels = { connected: 'net: on', disconnected: 'net: off', connecting: 'net: ...' };
            netStatusEl.textContent = labels[state] || state;
        }

        function updateTerminalSize() {
            if (term && fitAddon) {
                fitAddon.fit();
                // Notify worker of new terminal dimensions
                if (worker) {
                    worker.postMessage({ type: 'resize', rows: term.rows, cols: term.cols });
                }
            }
        }

        /**
         * Read stdout ring buffer and write to terminal.
         * Called on a polling interval from the main thread.
         */
        function drainStdout() {
            if (!stdoutView || !stdoutBytes || !term) return;

            const writeHead = Atomics.load(stdoutView, 0);
            const readTail = Atomics.load(stdoutView, 1);
            if (writeHead === readTail) return; // empty

            let available;
            if (writeHead >= readTail) {
                available = writeHead - readTail;
            } else {
                available = RING_SIZE - readTail + writeHead;
            }
            if (available <= 0) return;

            const buf = new Uint8Array(available);
            let pos = readTail;
            for (let i = 0; i < available; i++) {
                buf[i] = stdoutBytes[RING_HEADER + pos];
                pos = (pos + 1) % RING_SIZE;
            }

            // Update read tail
            Atomics.store(stdoutView, 1, pos);

            // Decode and write to terminal
            const text = new TextDecoder().decode(buf);
            term.write(text);
        }

        /**
         * Check if worker is requesting stdin. If so, provide data from stdinQueue.
         * Called on a polling interval from the main thread.
         */
        function checkStdinRequest() {
            if (!controlView) return;
            const cmd = Atomics.load(controlView, 0);
            if (cmd !== CMD_STDIN_REQUEST) return;

            // Worker wants stdin — wait until we have data
            if (stdinQueue.length === 0) return;

            const maxLen = Atomics.load(controlView, 2);
            const controlBytes = new Uint8Array(controlSab);
            const toSend = Math.min(stdinQueue.length, maxLen, 3968);

            for (let i = 0; i < toSend; i++) {
                controlBytes[64 + i] = stdinQueue.shift();
            }

            Atomics.store(controlView, 2, toSend);
            Atomics.store(controlView, 0, CMD_STDIN_READY);
            Atomics.notify(controlView, 0);
        }

        /**
         * Check for exit signal from worker.
         */
        function checkExit() {
            if (!controlView) return false;
            const cmd = Atomics.load(controlView, 0);
            if (cmd === CMD_EXIT) {
                machineRunning = false;
                const exitCode = Atomics.load(controlView, 5);
                term.writeln(`\r\n\x1b[33mProcess exited (code ${exitCode})\x1b[0m`);
                statusEl.textContent = `Exited (${exitCode})`;
                Atomics.store(controlView, 0, CMD_IDLE);
                return true;
            }
            return false;
        }

        const overlayEl = document.getElementById('progress-overlay');
        const stageEl = document.getElementById('progress-stage');
        const detailEl = document.getElementById('progress-detail');

        // Wavy progress bar — main (squiggly for page load)
        const waveCanvas = document.getElementById('progress-canvas');
        const waveCtx = waveCanvas.getContext('2d');
        let wavePct = 0;          // 0-100, or -1 for indeterminate
        let waveTarget = 0;       // smooth interpolation target
        let waveIndeterminate = false;
        let wavePhase = 0;
        let waveAnimId = null;

        // Main progress bar uses squiggly for page load
        let waveMode = 'squiggly';

        // SquigglyProgress — ported from Android SystemUI SquigglyProgress.kt
        // All measurements in CSS pixels (DPI-scaled automatically on canvas)
        const SQ_WAVE_LENGTH = 32;     // CSS px, one full wave period
        const SQ_LINE_AMP = 3;         // CSS px, peak amplitude (half of original)
        const SQ_PHASE_SPEED = 8;      // CSS px/sec, gentle scroll speed
        const SQ_STROKE_W = 6;         // CSS px, stroke width (2x original)
        const SQ_TRANSITION_PERIODS = 1.5;  // wavelengths over which amplitude fades (indeterminate mode)
        const SQ_DISABLED_ALPHA = 0.25; // alpha multiplier for unplayed flat line (~64/255)
        const SQ_TWO_PI = Math.PI * 2;

        // Sinusoidal wave parameters
        const SINE_WAVE_LENGTH = 40;   // CSS px, one full sine period
        const SINE_AMP = 4;            // CSS px, peak amplitude
        const SINE_PHASE_SPEED = 60;   // CSS px/sec, scrolling speed
        const SINE_STROKE_W = 3;       // CSS px, stroke width
        const SINE_STEP = 2;           // CSS px per lineTo segment (resolution)

        const FILL_COLOR = '#2ea043';
        const WARN_COLOR = '#d29922';
        const ERR_COLOR = '#e06c75';
        let waveColor = null;  // null = use FILL_COLOR

        let heightFraction = 1;  // amplitude scale (0=flat, 1=full wave)
        let sqPhaseOffset = 0;
        let sqLastTime = -1;

        let demoActive = false;

        // DPI-aware canvas setup (crisp on retina/high-DPI displays)
        function setupCanvasDPI(canvas, ctx) {
            const dpr = window.devicePixelRatio || 1;
            const cssW = canvas.clientWidth;
            const cssH = canvas.clientHeight;
            if (cssW > 0 && cssH > 0) {
                canvas.width = Math.round(cssW * dpr);
                canvas.height = Math.round(cssH * dpr);
                ctx.scale(dpr, dpr);
            }
        }
        setupCanvasDPI(waveCanvas, waveCtx);
        // Helper: clamp-lerp inverse (lerpInvSat)
        function lerpInvSat(a, b, v) {
            return Math.max(0, Math.min(1, (v - a) / (b - a)));
        }

        // Build the cubic-bezier wave path as an array of bezier segments.
        // Each half-wavelength is one cubic bezier curve.
        // Returns a Path2D spanning from waveStart to waveEnd.
        function buildWavePath(waveStart, waveEnd, waveProgressPx, transitionEnabled) {
            const path = new Path2D();
            path.moveTo(waveStart, 0);

            let currentX = waveStart;
            let waveSign = 1;
            const dist = SQ_WAVE_LENGTH / 2;

            function computeAmp(x, sign) {
                if (transitionEnabled) {
                    const length = SQ_TRANSITION_PERIODS * SQ_WAVE_LENGTH;
                    const coeff = lerpInvSat(
                        waveProgressPx + length / 2,
                        waveProgressPx - length / 2, x);
                    return sign * heightFraction * SQ_LINE_AMP * coeff;
                }
                return sign * heightFraction * SQ_LINE_AMP;
            }

            let currentAmp = computeAmp(currentX, waveSign);
            while (currentX < waveEnd) {
                waveSign = -waveSign;
                const nextX = currentX + dist;
                const midX = currentX + dist / 2;
                const nextAmp = computeAmp(nextX, waveSign);
                path.bezierCurveTo(midX, currentAmp, midX, nextAmp, nextX, nextAmp);
                currentAmp = nextAmp;
                currentX = nextX;
            }
            return path;
        }

        // --- Sinusoidal wave renderer ---
        // Draws a true Math.sin() wave with lineTo segments.
        // Smooth, continuous, no bezier discretization artifacts.
        function drawSineProgress(ctx, W, H, now, progress, color) {
            const midY = H / 2;
            const amp = SINE_AMP;
            const wl = SINE_WAVE_LENGTH;
            const sw = SINE_STROKE_W;
            const step = SINE_STEP;

            // Phase scrolls rightward continuously
            const phase = (now / 1000) * SINE_PHASE_SPEED;
            const totalProgressPx = W * progress;

            ctx.save();
            ctx.translate(0, midY);

            // Unplayed portion: dimmed flat line
            if (totalProgressPx < W) {
                ctx.save();
                ctx.strokeStyle = color;
                ctx.globalAlpha = SQ_DISABLED_ALPHA;
                ctx.lineWidth = sw;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(totalProgressPx, 0);
                ctx.lineTo(W, 0);
                ctx.stroke();
                ctx.restore();
            }

            // Played portion: sine wave (full alpha, clipped to progress)
            if (totalProgressPx > 0) {
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, -(amp + sw), totalProgressPx, (amp + sw) * 2);
                ctx.clip();
                ctx.strokeStyle = color;
                ctx.globalAlpha = 1;
                ctx.lineWidth = sw;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                for (let x = 0; x <= W; x += step) {
                    const y = Math.sin(SQ_TWO_PI * (x - phase) / wl) * amp;
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        }

        // --- Sinusoidal wave: indeterminate mode (pulsing full-width wave) ---
        function drawSineIndeterminate(ctx, W, H, now, color) {
            const midY = H / 2;
            const amp = SINE_AMP;
            const wl = SINE_WAVE_LENGTH;
            const sw = SINE_STROKE_W;
            const step = SINE_STEP;
            const phase = (now / 1000) * SINE_PHASE_SPEED;

            const fakeProgress = 1; // full width, just animate the wave
            const totalProgressPx = W * fakeProgress;

            ctx.save();
            ctx.translate(0, midY);

            // Full wave, dimmed
            ctx.save();
            ctx.beginPath();
            ctx.rect(totalProgressPx, -(amp + sw), W - totalProgressPx, (amp + sw) * 2);
            ctx.clip();
            ctx.strokeStyle = color;
            ctx.globalAlpha = SQ_DISABLED_ALPHA;
            ctx.lineWidth = sw;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            for (let x = 0; x <= W; x += step) {
                const y = Math.sin(SQ_TWO_PI * (x - phase) / wl) * amp;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();

            // Played portion, bright
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, -(amp + sw), totalProgressPx, (amp + sw) * 2);
            ctx.clip();
            ctx.strokeStyle = color;
            ctx.globalAlpha = 1;
            ctx.lineWidth = sw;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            for (let x = 0; x <= W; x += step) {
                const y = Math.sin(SQ_TWO_PI * (x - phase) / wl) * amp;
                if (x === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
            ctx.restore();

            ctx.restore();
        }

        // --- Squiggly (bezier) wave: determinate mode ---
        function drawSquigglyProgress(ctx, W, H, now, progress, color) {
            const midY = H / 2;
            const totalProgressPx = W * progress;
            const waveStart = -sqPhaseOffset - SQ_WAVE_LENGTH / 2;
            const path = buildWavePath(waveStart, totalProgressPx + SQ_WAVE_LENGTH, totalProgressPx, false);

            ctx.save();
            ctx.translate(0, midY);

            // Unplayed: flat line
            if (totalProgressPx < W) {
                ctx.save();
                ctx.strokeStyle = color;
                ctx.globalAlpha = SQ_DISABLED_ALPHA;
                ctx.lineWidth = SQ_STROKE_W;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(totalProgressPx, 0);
                ctx.lineTo(W, 0);
                ctx.stroke();
                ctx.restore();
            }

            // Played: squiggly wave clipped to progress
            if (totalProgressPx > 0) {
                ctx.save();
                ctx.beginPath();
                ctx.rect(0, -(SQ_LINE_AMP + SQ_STROKE_W),
                    totalProgressPx, (SQ_LINE_AMP + SQ_STROKE_W) * 2);
                ctx.clip();
                ctx.strokeStyle = color;
                ctx.globalAlpha = 1;
                ctx.lineWidth = SQ_STROKE_W;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.stroke(path);
                ctx.restore();
            }

            // Round cap at x=0
            const startAmp = Math.cos(Math.abs(waveStart) / SQ_WAVE_LENGTH * SQ_TWO_PI);
            ctx.beginPath();
            ctx.arc(0, startAmp * SQ_LINE_AMP * heightFraction,
                SQ_STROKE_W / 2, 0, SQ_TWO_PI);
            ctx.fillStyle = color;
            ctx.fill();

            ctx.restore();
        }

        // --- Squiggly (bezier) wave: indeterminate mode ---
        function drawSquigglyIndeterminate(ctx, W, H, now, color) {
            const midY = H / 2;
            const fakeProgress = 1; // full width, just animate the wave
            const totalProgressPx = W * fakeProgress;
            const waveStart = -sqPhaseOffset - SQ_WAVE_LENGTH / 2;
            const path = buildWavePath(waveStart, W, totalProgressPx, true);

            ctx.save();
            ctx.translate(0, midY);

            // Unplayed (dimmed)
            ctx.save();
            ctx.beginPath();
            ctx.rect(totalProgressPx, -(SQ_LINE_AMP + SQ_STROKE_W),
                W - totalProgressPx, (SQ_LINE_AMP + SQ_STROKE_W) * 2);
            ctx.clip();
            ctx.strokeStyle = color;
            ctx.globalAlpha = SQ_DISABLED_ALPHA;
            ctx.lineWidth = SQ_STROKE_W;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke(path);
            ctx.restore();

            // Played (full alpha)
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, -(SQ_LINE_AMP + SQ_STROKE_W),
                totalProgressPx, (SQ_LINE_AMP + SQ_STROKE_W) * 2);
            ctx.clip();
            ctx.strokeStyle = color;
            ctx.globalAlpha = 1;
            ctx.lineWidth = SQ_STROKE_W;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke(path);
            ctx.restore();

            // Round cap at x=0
            const startAmp = Math.cos(Math.abs(waveStart) / SQ_WAVE_LENGTH * SQ_TWO_PI);
            ctx.beginPath();
            ctx.arc(0, startAmp * SQ_LINE_AMP * heightFraction,
                SQ_STROKE_W / 2, 0, SQ_TWO_PI);
            ctx.fillStyle = color;
            ctx.fill();

            ctx.restore();
        }

        // Ensure canvas pixel buffer matches CSS size (call each frame)
        function ensureCanvasDPI(canvas, ctx) {
            const dpr = window.devicePixelRatio || 1;
            const cssW = canvas.clientWidth;
            const cssH = canvas.clientHeight;
            const pixW = Math.round(cssW * dpr);
            const pixH = Math.round(cssH * dpr);
            if (pixW > 0 && pixH > 0 && (canvas.width !== pixW || canvas.height !== pixH)) {
                canvas.width = pixW;
                canvas.height = pixH;
                ctx.scale(dpr, dpr);
            }
            return { W: cssW, H: cssH };
        }

        // --- Single unified animation loop (no racing rAF callbacks) ---
        function drawWave(timestamp) {
            const now = timestamp || performance.now();

            if (!demoActive && !waveIndeterminate) {
                wavePct += (waveTarget - wavePct) * 0.12;
            }

            // Squiggly phase animation (time-based)
            if (sqLastTime < 0) sqLastTime = now;
            sqPhaseOffset += (now - sqLastTime) / 1000 * SQ_PHASE_SPEED;
            sqPhaseOffset %= SQ_WAVE_LENGTH;
            sqLastTime = now;

            const color = waveColor || FILL_COLOR;
            const progress = wavePct / 100;

            // --- Main progress canvas (squiggly for page load) ---
            {
                const { W, H } = ensureCanvasDPI(waveCanvas, waveCtx);
                waveCtx.clearRect(0, 0, W, H);
                if (waveIndeterminate) {
                    if (waveMode === 'sine') drawSineIndeterminate(waveCtx, W, H, now, color);
                    else drawSquigglyIndeterminate(waveCtx, W, H, now, color);
                } else {
                    if (waveMode === 'sine') drawSineProgress(waveCtx, W, H, now, progress, color);
                    else drawSquigglyProgress(waveCtx, W, H, now, progress, color);
                }
            }

            waveAnimId = requestAnimationFrame(drawWave);
        }

        // Start single animation loop
        waveAnimId = requestAnimationFrame(drawWave);

        function setProgress(pct, stage, detail) {
            demoActive = false; // real progress overrides demo
            if (stage) stageEl.textContent = stage;
            if (pct < 0) {
                waveIndeterminate = true;
            } else {
                waveIndeterminate = false;
                waveTarget = pct;
            }
            detailEl.textContent = detail || '\u00a0';
        }

        function formatBytes(bytes) {
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(0) + ' KB';
            return (bytes / 1024 / 1024).toFixed(1) + ' MB';
        }

        const STALL_TIMEOUT_MS = 10000;  // 10s with no data = stalled
        const MAX_RETRIES = 5;
        const RETRY_DELAYS = [1000, 2000, 4000, 8000, 15000]; // backoff

        async function fetchWithProgress(url) {
            // First request to get total size
            let total = 0;
            const chunks = [];
            let loaded = 0;
            let retries = 0;
            const startTime = performance.now();

            while (true) {
                try {
                    const headers = {};
                    if (loaded > 0) {
                        headers['Range'] = `bytes=${loaded}-`;
                    }

                    waveColor = null; // reset to green
                    const resp = await fetch(url, { headers });

                    if (!resp.ok && resp.status !== 206) {
                        throw new Error(`HTTP ${resp.status}`);
                    }

                    // Get total size from first request or Content-Range on resume
                    if (total === 0) {
                        if (resp.status === 206) {
                            const range = resp.headers.get('Content-Range');
                            if (range) total = parseInt(range.split('/')[1], 10) || 0;
                        } else {
                            total = parseInt(resp.headers.get('Content-Length'), 10) || 0;
                        }
                    }

                    if (!resp.body) {
                        // No streaming support — fallback
                        const buf = await resp.arrayBuffer();
                        setProgress(100, null, formatBytes(buf.byteLength) + ' downloaded');
                        return buf;
                    }

                    const reader = resp.body.getReader();
                    retries = 0; // reset on successful connection

                    if (loaded > 0) {
                        waveColor = null;
                        setProgress(
                            total ? Math.round((loaded / total) * 100) : -1,
                            `Downloading (resumed)...`
                        );
                    }

                    while (true) {
                        // Race read against stall timeout
                        const readPromise = reader.read();
                        const timeoutPromise = new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('stall')), STALL_TIMEOUT_MS)
                        );

                        let result;
                        try {
                            result = await Promise.race([readPromise, timeoutPromise]);
                        } catch (e) {
                            // Stall detected — abort this reader and retry
                            try { reader.cancel(); } catch (_) {}
                            waveColor = WARN_COLOR;
                            setProgress(
                                total ? Math.round((loaded / total) * 100) : -1,
                                null,
                                'Download stalled, retrying...'
                            );
                            throw e;
                        }

                        const { done, value } = result;
                        if (done) break;

                        chunks.push(value);
                        loaded += value.length;
                        const pct = total ? Math.min(99, Math.round((loaded / total) * 100)) : -1;
                        const elapsed = (performance.now() - startTime) / 1000;
                        const speed = elapsed > 0 ? loaded / elapsed : 0;
                        setProgress(pct, null,
                            `${formatBytes(loaded)} / ${total ? formatBytes(total) : '?'}  \u2022  ${formatBytes(speed)}/s`);
                    }

                    // Download complete
                    break;

                } catch (err) {
                    retries++;
                    if (retries > MAX_RETRIES) {
                        waveColor = ERR_COLOR;
                        setProgress(
                            total ? Math.round((loaded / total) * 100) : 0,
                            'Download failed',
                            `${err.message} \u2014 reload to retry`
                        );
                        throw new Error(`Download failed after ${MAX_RETRIES} retries: ${err.message}`);
                    }

                    const delay = RETRY_DELAYS[Math.min(retries - 1, RETRY_DELAYS.length - 1)];
                    waveColor = WARN_COLOR;

                    // Countdown retry timer
                    for (let remaining = Math.ceil(delay / 1000); remaining > 0; remaining--) {
                        setProgress(
                            total ? Math.round((loaded / total) * 100) : 0,
                            null,
                            `Connection lost \u2014 retrying in ${remaining}s (attempt ${retries}/${MAX_RETRIES})`
                        );
                        await new Promise(r => setTimeout(r, 1000));
                    }

                    setProgress(
                        total ? Math.round((loaded / total) * 100) : 0,
                        null,
                        `Reconnecting... (attempt ${retries}/${MAX_RETRIES})`
                    );
                }
            }

            // Combine chunks
            const result = new Uint8Array(loaded);
            let offset = 0;
            for (const chunk of chunks) {
                result.set(chunk, offset);
                offset += chunk.length;
            }
            waveColor = null;
            setProgress(100, null, formatBytes(loaded) + ' downloaded');
            return result.buffer;
        }

        async function main() {
            // Check for SharedArrayBuffer support (requires COOP/COEP headers)
            if (typeof SharedArrayBuffer === 'undefined') {
                statusEl.textContent = 'Error: SharedArrayBuffer not available';
                stageEl.textContent = 'Cross-origin isolation required';
                detailEl.textContent = 'Serve with COOP/COEP headers (use serve.js)';
                return;
            }

            // Import tab: show import panel instead of booting
            if (activeExample === 'import') {
                overlayEl.style.display = 'none';
                document.getElementById('import-panel').classList.add('visible');
                statusEl.textContent = 'Import';
                initImportPanel();
                return;
            }

            setProgress(-1, 'Loading manifest...');
            const manifest = await fetch('./manifest.json').then(r => r.json());

            // Resolve example-specific config (rootfs, entrypoint, image name)
            const exampleCfg = (activeExample && manifest.examples && manifest.examples[activeExample]) || {};
            const imageName = exampleCfg.image || manifest.image;
            const rootfsUrl = exampleCfg.rootfs || manifest.rootfs || './rootfs.tar';
            statusEl.textContent = `Loading ${imageName}...`;

            // Download rootfs with progress
            setProgress(0, `Loading ${imageName}...`, 'Starting download...');
            const rootfs = await fetchWithProgress(rootfsUrl);

            // Initialize runtime (indeterminate)
            setProgress(-1, 'Initializing runtime...');

            // Initialize xterm.js (hidden behind overlay)
            term = new Terminal({
                cursorBlink: true,
                convertEol: true,
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#0d1117',
                    foreground: '#c9d1d9',
                    selectionBackground: '#00507a',
                    cursor: '#c9d1d9',
                    black: '#000000',
                    red: '#e06c75',
                    green: '#98c379',
                    yellow: '#e5c07b',
                    blue: '#61afef',
                    magenta: '#c678dd',
                    cyan: '#56b6c2',
                    white: '#ffffff',
                    brightBlack: '#5c6370',
                    brightRed: '#e06c75',
                    brightGreen: '#98c379',
                    brightYellow: '#e5c07b',
                    brightBlue: '#61afef',
                    brightMagenta: '#c678dd',
                    brightCyan: '#56b6c2',
                    brightWhite: '#ffffff',
                }
            });
            fitAddon = new FitAddon();
            term.loadAddon(fitAddon);
            term.open(terminalEl);

            function debounce(fn, ms) {
                let id;
                return (...args) => { clearTimeout(id); id = setTimeout(() => fn(...args), ms); };
            }
            const debouncedFit = debounce(updateTerminalSize, 150);

            window.addEventListener('resize', debouncedFit);
            terminalEl.addEventListener('click', () => term.focus());

            // Create SharedArrayBuffers for Worker communication
            controlSab = new SharedArrayBuffer(4096);   // Control channel
            stdoutSab = new SharedArrayBuffer(65536);    // 64KB stdout ring buffer
            netSab = new SharedArrayBuffer(65536);       // 64KB network RPC

            controlView = new Int32Array(controlSab);
            stdoutView = new Int32Array(stdoutSab);
            stdoutBytes = new Uint8Array(stdoutSab);

            // Write initial terminal dimensions into control SAB
            fitAddon.fit();
            Atomics.store(controlView, 6, term.cols);  // offset 24
            Atomics.store(controlView, 7, term.rows);  // offset 28

            // Spawn Worker
            setProgress(-1, 'Starting worker...');
            worker = new Worker('./worker.js', { type: 'module' });

            // Wait for Worker to be ready
            const workerReady = new Promise((resolve, reject) => {
                const onMsg = (e) => {
                    if (e.data.type === 'ready') { resolve(); worker.onmessage = null; }
                    if (e.data.type === 'error') reject(new Error(`Worker: ${e.data.message}`));
                };
                worker.onmessage = onMsg;
                worker.onerror = (e) => {
                    const detail = e.message || `${e.filename || 'worker.js'}:${e.lineno || '?'}`;
                    console.error('[main] Worker error:', detail, e);
                    reject(new Error(`Worker failed: ${detail}`));
                };
            });

            // Send init message with SABs
            worker.postMessage({
                type: 'init',
                controlSab,
                stdoutSab,
                netSab,
            });

            await workerReady;

            // Connect network bridge (optional — needs proxy server)
            // Priority: ?noproxy disables > ?proxy= param > localhost > default public proxy
            const DEFAULT_PROXY = 'https://78.141.219.102:4433/connect';
            const params = new URLSearchParams(location.search);
            const proxyUrl = params.has('noproxy') ? null
                           : params.get('proxy')
                             || (location.hostname === 'localhost' || location.hostname === '127.0.0.1'
                                 ? `https://${location.hostname}:4433/connect` : DEFAULT_PROXY);
            if (proxyUrl) {
                setProgress(-1, 'Connecting network...');
                try {
                    updateNetStatus('connecting');
                    netBridge = new FriscyNetworkBridge(proxyUrl);
                    await netBridge.connect();
                    updateNetStatus('connected');
                } catch (e) {
                    updateNetStatus('disconnected');
                    console.warn('[friscy] Network bridge not available:', e.message);
                }
            } else {
                updateNetStatus('disconnected');
            }

            // Start network RPC host (polls netSab for worker requests)
            if (netBridge) {
                netRPCHost = new NetworkRPCHost(netSab, netBridge);
                netRPCHost.start();
            }

            // Transition: hide progress overlay, show terminal + reset button
            overlayEl.classList.add('hidden');
            terminalEl.style.display = 'flex';
            document.getElementById('reset-btn').style.display = 'block';
            term.focus();
            updateTerminalSize();

            const rootfsMB = (rootfs.byteLength / 1024 / 1024).toFixed(1);
            term.writeln('\x1b[4:3m\x1b[58;2;255;0;255mRun Docker containers in the browser. friscy cross-compiles Linux containers to RISC-V and executes them in a userland emulator compiled to WebAssembly.\x1b[0m');
            term.writeln('');
            term.writeln('\x1b[1;32mfriscy\x1b[0m fast risc-v runtime for the browser & wasm');
            term.writeln(`Image: ${manifest.image} (${rootfsMB} MB)`);
            term.writeln(netBridge && netBridge.isAvailable()
                ? '\x1b[32mNetwork: connected\x1b[0m'
                : '\x1b[33mNetwork: offline (no proxy)\x1b[0m');
            term.writeln('');

            // --- Clipboard support (Ctrl+C copy / Ctrl+V paste) + Tab capture ---
            term.attachCustomKeyEventHandler((ev) => {
                if (ev.type === 'keydown' && ev.ctrlKey && ev.key === 'c' && term.hasSelection()) {
                    navigator.clipboard.writeText(term.getSelection());
                    return false;
                }
                if (ev.type === 'keydown' && ev.ctrlKey && ev.key === 'v') {
                    navigator.clipboard.readText().then(text => {
                        if (text) term.paste(text);
                    }).catch(() => {});
                    return false;
                }
                // Capture Tab key — send \t to guest shell for tab completion
                if (ev.key === 'Tab') {
                    ev.preventDefault();
                    return true; // let xterm process it (sends \t via onData)
                }
                return true;
            });

            // --- Input handler: raw passthrough to guest stdin via SAB ---
            term.onData((data) => {
                if (!machineRunning) return;

                for (let i = 0; i < data.length; i++) {
                    const code = data.charCodeAt(i);

                    if (code === 3) {
                        stdinQueue.push(0x03);
                    } else if (code === 26) {
                        stdinQueue.push(0x1a);
                    } else if (code === 12) {
                        term.clear();
                        stdinQueue.push(0x0c);
                    } else if (code === 4) {
                        stdinQueue.push(0x04);
                    } else if (data[i] === '\r') {
                        stdinQueue.push(0x0a);
                    } else if (code === 127) {
                        stdinQueue.push(0x7f);
                    } else if (code === 27) {
                        const bytes = new TextEncoder().encode(data.slice(i));
                        stdinQueue.push(...bytes);
                        break;
                    } else {
                        const bytes = new TextEncoder().encode(data[i]);
                        stdinQueue.push(...bytes);
                    }
                }

                // If worker is currently requesting stdin, fulfill it immediately
                checkStdinRequest();
            });

            // Start main polling loop: stdout drain, stdin check, exit check
            const pollTimer = setInterval(() => {
                drainStdout();
                checkStdinRequest();
                if (checkExit()) {
                    clearInterval(pollTimer);
                    if (netRPCHost) netRPCHost.stop();
                }
            }, 4); // ~4ms polling for responsive I/O

            // Build args matching main.cpp: --rootfs <tar> <entry> [args...]
            const entrypoint = exampleCfg.entrypoint || manifest.entrypoint;
            const guestCmd = Array.isArray(entrypoint) ? entrypoint : entrypoint.split(' ').filter(s => s);
            const args = ['--rootfs', '/rootfs.tar', ...guestCmd];

            statusEl.textContent = 'Booting...';
            machineRunning = true;

            // Send rootfs data + run command to worker
            // Transfer the ArrayBuffer to avoid copying 100+ MB
            const rootfsArray = new Uint8Array(rootfs);
            worker.postMessage({
                type: 'run',
                args,
                rootfsData: rootfsArray.buffer,
            }, [rootfsArray.buffer]);

            statusEl.innerHTML = 'fast risc-v runtime for the browser &amp; wasm' + document.getElementById('net-status').outerHTML;

            // Auto-run uname -a on Alpine boot — wait until shell is ready (requesting stdin)
            if (activeExample === 'alpine') {
                const waitForShell = () => {
                    // controlView[0] == 1 means worker is blocking on stdin (shell prompt ready)
                    if (controlView && Atomics.load(controlView, 0) === 1) {
                        const cmd = 'uname -a\n';
                        for (let i = 0; i < cmd.length; i++) {
                            stdinQueue.push(cmd.charCodeAt(i));
                        }
                        checkStdinRequest();
                    } else {
                        setTimeout(waitForShell, 200);
                    }
                };
                setTimeout(waitForShell, 1000);
            }
        }

        // --- Tab bar ---
        const params = new URLSearchParams(location.search);
        const activeExample = params.get('example') || 'alpine';

        // Set active tab
        document.querySelectorAll('.tab').forEach(tab => {
            if (tab.dataset.example === activeExample) tab.classList.add('active');
            else tab.classList.remove('active');
        });

        function switchExample(name) {
            const u = new URL(location);
            if (name === 'alpine') u.searchParams.delete('example');
            else u.searchParams.set('example', name);
            location.href = u;
        }
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => switchExample(tab.dataset.example));
        });
        document.getElementById('reset-btn').addEventListener('click', () => location.reload());

        // --- Popular Docker images for autocomplete (riscv64-available) ---
        const POPULAR_IMAGES = [
            'ubuntu','alpine','debian','busybox','centos','fedora','archlinux','amazonlinux','oraclelinux','rockylinux','almalinux','clearlinux',
            'node','python','ruby','rust','golang','openjdk','eclipse-temurin','amazoncorretto','php','perl','erlang','elixir','swift','dart','julia','haskell','clojure','groovy','scala','dotnet/sdk','dotnet/runtime',
            'nginx','httpd','caddy','traefik','haproxy','envoyproxy/envoy',
            'postgres','mysql','mariadb','mongo','redis','memcached','cassandra','couchdb','neo4j','influxdb','clickhouse/clickhouse-server','timescale/timescaledb',
            'rabbitmq','nats','mosquitto','kafka',
            'elasticsearch','kibana','logstash','grafana/grafana','prom/prometheus','prom/alertmanager',
            'vault','consul','etcd',
            'docker','docker/compose','registry','portainer/portainer-ce',
            'jenkins/jenkins','gitlab/gitlab-ce','gitea/gitea','drone/drone','sonarqube',
            'nextcloud','wordpress','ghost','mediawiki','drupal','joomla',
            'minio/minio','rclone/rclone',
            'ubuntu:22.04','ubuntu:24.04','ubuntu:latest','debian:bookworm','debian:bullseye','alpine:3.19','alpine:3.20','alpine:edge',
            'node:22','node:20','node:lts','node:alpine','python:3.12','python:3.11','python:slim','python:alpine',
            'rust:latest','rust:slim','rust:alpine','golang:1.22','golang:1.21','golang:alpine',
            'nginx:alpine','nginx:latest','redis:alpine','redis:latest','postgres:16','postgres:15','postgres:alpine',
            'mongo:7','mongo:6','mysql:8','mariadb:11','mariadb:10',
            'gcc','cmake','maven','gradle','composer','pip','cargo','npm',
            'curl','wget','git','openssh-server','openssl',
            'bash','zsh','fish','tmux','vim','neovim','emacs',
            'ubuntu:20.04','ubuntu:18.04','centos:7','fedora:39','fedora:40',
        ];

        function initImportPanel() {
            const input = document.getElementById('import-input');
            const chip = document.getElementById('import-chip');
            const ac = document.getElementById('import-ac');
            const goBtn = document.getElementById('import-go-btn');
            const statusDiv = document.getElementById('import-status');
            const importCanvas = document.getElementById('import-progress-canvas');
            const importCtx = importCanvas.getContext('2d');
            let importProgress = 0;
            let importAnimId = null;
            const PINK = '#f9a8d4';

            function drawImportProgress() {
                const { W, H } = ensureCanvasDPI(importCanvas, importCtx);
                importCtx.clearRect(0, 0, W, H);
                if (importProgress < 0) {
                    // Indeterminate
                    drawSquigglyIndeterminate(importCtx, W, H, performance.now(), PINK);
                } else {
                    drawSquigglyProgress(importCtx, W, H, performance.now(), importProgress, PINK);
                }
                importAnimId = requestAnimationFrame(drawImportProgress);
            }
            let selectedIdx = -1;
            let filtered = [];

            // Chip behavior: visible when input empty and not focused
            function updateChip() {
                chip.classList.toggle('hidden', input.value.length > 0 || document.activeElement === input);
            }

            input.addEventListener('focus', () => { chip.classList.add('hidden'); });
            input.addEventListener('blur', () => { setTimeout(updateChip, 150); });
            input.addEventListener('input', () => {
                updateChip();
                updateAutocomplete();
            });

            // Click on chip fills input and focuses
            chip.addEventListener('click', () => {
                input.value = 'ubuntu:latest';
                chip.classList.add('hidden');
                input.focus();
                updateAutocomplete();
            });

            function updateAutocomplete() {
                const q = input.value.trim().toLowerCase();
                if (!q) { ac.classList.remove('open'); filtered = []; return; }
                filtered = POPULAR_IMAGES.filter(img => img.toLowerCase().includes(q)).slice(0, 12);
                if (filtered.length === 0 || (filtered.length === 1 && filtered[0] === q)) {
                    ac.classList.remove('open');
                    return;
                }
                selectedIdx = -1;
                renderAC();
                ac.classList.add('open');
            }

            function renderAC() {
                const q = input.value.trim().toLowerCase();
                ac.innerHTML = filtered.map((img, i) => {
                    const idx = img.toLowerCase().indexOf(q);
                    let html;
                    if (idx >= 0) {
                        html = escHtml(img.slice(0, idx))
                            + '<span class="match">' + escHtml(img.slice(idx, idx + q.length)) + '</span>'
                            + escHtml(img.slice(idx + q.length));
                    } else {
                        html = escHtml(img);
                    }
                    return `<div class="import-ac-item${i === selectedIdx ? ' selected' : ''}" data-idx="${i}">${html}</div>`;
                }).join('');
            }

            function escHtml(s) {
                return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            }

            ac.addEventListener('mousedown', (e) => {
                const item = e.target.closest('.import-ac-item');
                if (item) {
                    input.value = filtered[+item.dataset.idx];
                    ac.classList.remove('open');
                    input.focus();
                }
            });

            input.addEventListener('keydown', (e) => {
                if (!ac.classList.contains('open')) {
                    if (e.key === 'Enter') { doImport(); e.preventDefault(); }
                    if (e.key === 'Tab' && input.value === '') {
                        e.preventDefault();
                        input.value = 'ubuntu:latest';
                        chip.classList.add('hidden');
                        updateAutocomplete();
                    }
                    return;
                }
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    selectedIdx = Math.min(selectedIdx + 1, filtered.length - 1);
                    renderAC();
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    selectedIdx = Math.max(selectedIdx - 1, -1);
                    renderAC();
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    if (selectedIdx >= 0) input.value = filtered[selectedIdx];
                    ac.classList.remove('open');
                    if (input.value.trim()) doImport();
                } else if (e.key === 'Escape') {
                    ac.classList.remove('open');
                } else if (e.key === 'Tab') {
                    e.preventDefault();
                    if (selectedIdx >= 0) input.value = filtered[selectedIdx];
                    else if (filtered.length > 0) input.value = filtered[0];
                    ac.classList.remove('open');
                }
            });

            // Handle both button click and form submit (for WebMCP declarative API)
            const importForm = document.getElementById('import-form');
            importForm.addEventListener('submit', (e) => { e.preventDefault(); doImport(); });

            async function doImport() {
                let image = input.value.trim();
                if (!image) {
                    image = 'ubuntu:latest';
                    input.value = image;
                }
                // Add :latest if no tag specified
                if (!image.includes(':')) image += ':latest';

                goBtn.disabled = true;
                input.disabled = true;
                ac.classList.remove('open');
                statusDiv.textContent = `Pulling ${image}...`;
                importCanvas.classList.add('visible');
                importProgress = -1; // indeterminate until we know size
                if (!importAnimId) importAnimId = requestAnimationFrame(drawImportProgress);

                try {
                    // Determine proxy pull URL (Caddy reverse proxy with valid Let's Encrypt cert)
                    const proxyHost = (location.hostname === 'localhost' || location.hostname === '127.0.0.1')
                        ? `https://${location.hostname}:4434`
                        : 'https://78.141.219.102.nip.io';
                    const pullUrl = `${proxyHost}/pull?image=${encodeURIComponent(image)}`;

                    const resp = await fetch(pullUrl);
                    if (!resp.ok) {
                        const errText = await resp.text();
                        throw new Error(errText || `HTTP ${resp.status}`);
                    }

                    const total = parseInt(resp.headers.get('Content-Length') || '0', 10);
                    const reader = resp.body.getReader();
                    const chunks = [];
                    let loaded = 0;

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        chunks.push(value);
                        loaded += value.length;
                        importProgress = total ? loaded / total : -1;
                        statusDiv.textContent = `Pulling ${image}... ${(loaded/1024/1024).toFixed(1)} MB` + (total ? ` / ${(total/1024/1024).toFixed(1)} MB` : '');
                    }

                    importProgress = 1.0;
                    statusDiv.textContent = `Booting ${image}...`;

                    // Combine chunks into rootfs ArrayBuffer
                    const rootfs = new Uint8Array(loaded);
                    let off = 0;
                    for (const c of chunks) { rootfs.set(c, off); off += c.length; }

                    // Boot the emulator with this rootfs
                    importCanvas.classList.remove('visible');
                    if (importAnimId) { cancelAnimationFrame(importAnimId); importAnimId = null; }
                    await bootImportedImage(image, rootfs.buffer);

                } catch (e) {
                    statusDiv.textContent = `Error: ${e.message}`;
                    importCanvas.classList.remove('visible');
                    if (importAnimId) { cancelAnimationFrame(importAnimId); importAnimId = null; }
                    goBtn.disabled = false;
                    input.disabled = false;
                }
            }
        }

        // Boot an imported Docker image (reuses the normal boot flow)
        async function bootImportedImage(imageName, rootfs) {
            const importPanel = document.getElementById('import-panel');
            const importStatus = document.getElementById('import-status');

            // Hide import panel, show progress overlay
            importPanel.classList.remove('visible');
            overlayEl.style.display = '';
            setProgress(-1, 'Initializing runtime...');

            // Initialize xterm
            term = new Terminal({
                cursorBlink: true,
                convertEol: true,
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                theme: {
                    background: '#0d1117', foreground: '#c9d1d9',
                    selectionBackground: '#00507a', cursor: '#c9d1d9',
                    black: '#000000', red: '#e06c75', green: '#98c379',
                    yellow: '#e5c07b', blue: '#61afef', magenta: '#c678dd',
                    cyan: '#56b6c2', white: '#ffffff',
                    brightBlack: '#5c6370', brightRed: '#e06c75', brightGreen: '#98c379',
                    brightYellow: '#e5c07b', brightBlue: '#61afef', brightMagenta: '#c678dd',
                    brightCyan: '#56b6c2', brightWhite: '#ffffff',
                }
            });
            fitAddon = new FitAddon();
            term.loadAddon(fitAddon);
            term.open(terminalEl);
            terminalEl.addEventListener('click', () => term.focus());

            const debouncedFit = debounce(updateTerminalSize, 150);
            window.addEventListener('resize', debouncedFit);

            controlSab = new SharedArrayBuffer(4096);
            stdoutSab = new SharedArrayBuffer(65536);
            netSab = new SharedArrayBuffer(65536);
            controlView = new Int32Array(controlSab);
            stdoutView = new Int32Array(stdoutSab);
            stdoutBytes = new Uint8Array(stdoutSab);
            fitAddon.fit();
            Atomics.store(controlView, 6, term.cols);
            Atomics.store(controlView, 7, term.rows);

            setProgress(-1, 'Starting worker...');
            worker = new Worker('./worker.js', { type: 'module' });
            const workerReady = new Promise((resolve, reject) => {
                const onMsg = (e) => {
                    if (e.data.type === 'ready') { resolve(); worker.onmessage = null; }
                    if (e.data.type === 'error') reject(new Error(`Worker: ${e.data.message}`));
                };
                worker.onmessage = onMsg;
                worker.onerror = (e) => reject(new Error(`Worker failed: ${e.message || 'unknown'}`));
            });
            worker.postMessage({ type: 'init', controlSab, stdoutSab, netSab });
            await workerReady;

            // Connect network
            const DEFAULT_PROXY = 'https://78.141.219.102:4433/connect';
            const params = new URLSearchParams(location.search);
            const proxyUrl = params.has('noproxy') ? null
                           : params.get('proxy')
                             || (location.hostname === 'localhost' || location.hostname === '127.0.0.1'
                                 ? `https://${location.hostname}:4433/connect` : DEFAULT_PROXY);
            if (proxyUrl) {
                try {
                    updateNetStatus('connecting');
                    netBridge = new FriscyNetworkBridge(proxyUrl);
                    await netBridge.connect();
                    updateNetStatus('connected');
                } catch (e) { updateNetStatus('disconnected'); }
            } else { updateNetStatus('disconnected'); }
            if (netBridge) { netRPCHost = new NetworkRPCHost(netSab, netBridge); netRPCHost.start(); }

            // Show terminal
            overlayEl.classList.add('hidden');
            terminalEl.style.display = 'flex';
            document.getElementById('reset-btn').style.display = 'block';
            term.focus();
            updateTerminalSize();

            const rootfsMB = (rootfs.byteLength / 1024 / 1024).toFixed(1);
            term.writeln('\x1b[4:3m\x1b[58;2;255;0;255mRun Docker containers in the browser. friscy cross-compiles Linux containers to RISC-V and executes them in a userland emulator compiled to WebAssembly.\x1b[0m');
            term.writeln('');
            term.writeln('\x1b[1;32mfriscy\x1b[0m fast risc-v runtime for the browser & wasm');
            term.writeln(`Image: ${imageName} (${rootfsMB} MB)`);
            term.writeln(netBridge && netBridge.isAvailable()
                ? '\x1b[32mNetwork: connected\x1b[0m'
                : '\x1b[33mNetwork: offline (no proxy)\x1b[0m');
            term.writeln('');

            // Clipboard + Tab capture
            term.attachCustomKeyEventHandler((ev) => {
                if (ev.type === 'keydown' && ev.ctrlKey && ev.key === 'c' && term.hasSelection()) {
                    navigator.clipboard.writeText(term.getSelection()); return false;
                }
                if (ev.type === 'keydown' && ev.ctrlKey && ev.key === 'v') {
                    navigator.clipboard.readText().then(t => { if (t) term.paste(t); }).catch(() => {});
                    return false;
                }
                if (ev.key === 'Tab') { ev.preventDefault(); return true; }
                return true;
            });

            // stdin handler
            term.onData((data) => {
                if (!machineRunning) return;
                for (let i = 0; i < data.length; i++) {
                    const code = data.charCodeAt(i);
                    if (code === 3) stdinQueue.push(0x03);
                    else if (code === 26) stdinQueue.push(0x1a);
                    else if (code === 12) { term.clear(); stdinQueue.push(0x0c); }
                    else if (code === 4) stdinQueue.push(0x04);
                    else if (data[i] === '\r') stdinQueue.push(0x0a);
                    else if (code === 127) stdinQueue.push(0x7f);
                    else if (code === 27) { stdinQueue.push(...new TextEncoder().encode(data.slice(i))); break; }
                    else stdinQueue.push(...new TextEncoder().encode(data[i]));
                }
                checkStdinRequest();
            });

            const pollTimer = setInterval(() => {
                drainStdout();
                checkStdinRequest();
                if (checkExit()) { clearInterval(pollTimer); if (netRPCHost) netRPCHost.stop(); }
            }, 4);

            // Boot: use /bin/sh as default entrypoint for imported images
            const args = ['--rootfs', '/rootfs.tar', '/bin/sh'];
            statusEl.textContent = 'Booting...';
            machineRunning = true;
            const rootfsArray = new Uint8Array(rootfs);
            worker.postMessage({ type: 'run', args, rootfsData: rootfsArray.buffer }, [rootfsArray.buffer]);
            statusEl.innerHTML = 'fast risc-v runtime for the browser &amp; wasm' + document.getElementById('net-status').outerHTML;
        }

        function debounce(fn, ms) {
            let id;
            return (...args) => { clearTimeout(id); id = setTimeout(() => fn(...args), ms); };
        }

        main().catch(e => {
            console.error(e);
            statusEl.textContent = 'Error: ' + e.message;
            stageEl.textContent = 'Error';
            detailEl.textContent = e.message;
            waveColor = ERR_COLOR;
        });

        // --- WebMCP: Expose friscy tools to AI agents ---
        // https://developer.chrome.com/blog/webmcp-epp
        if ('modelContext' in navigator) {
            // Tool 1: Run a shell command in the active container
            navigator.modelContext.registerTool({
                name: 'run_command',
                description: 'Run a shell command in the friscy Linux container and return stdout. The container is a RISC-V Alpine Linux running in-browser via WebAssembly.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        command: {
                            type: 'string',
                            description: 'The shell command to execute (e.g. "ls -la", "uname -a", "cat /etc/os-release")'
                        }
                    },
                    required: ['command']
                },
                async execute({ command }) {
                    if (!machineRunning) {
                        return { error: 'No container is running. Switch to a tab (Alpine, Node.js, Go Server) first.' };
                    }
                    // Inject command + newline into stdin
                    const cmd = command + '\n';
                    for (let i = 0; i < cmd.length; i++) {
                        stdinQueue.push(cmd.charCodeAt(i));
                    }
                    checkStdinRequest();

                    // Wait for output to settle (command execution + flush)
                    await new Promise(r => setTimeout(r, 1500));
                    drainStdout();

                    // Read recent terminal content
                    const buffer = term.buffer.active;
                    const lines = [];
                    for (let i = Math.max(0, buffer.cursorY - 40); i <= buffer.cursorY; i++) {
                        const line = buffer.getLine(i);
                        if (line) lines.push(line.translateToString(true));
                    }
                    return { output: lines.join('\n') };
                }
            });

            // Tool 2: Import and boot a Docker image
            navigator.modelContext.registerTool({
                name: 'import_docker_image',
                description: 'Pull a Docker image from Docker Hub and boot it in friscy. Supports any public image (e.g. "ubuntu:latest", "python:3.12", "rust:latest"). The image is pulled as riscv64 if available, otherwise amd64.',
                inputSchema: {
                    type: 'object',
                    properties: {
                        image: {
                            type: 'string',
                            description: 'Docker image reference (e.g. "ubuntu:latest", "node:22-alpine", "rust:slim")'
                        }
                    },
                    required: ['image']
                },
                async execute({ image }) {
                    if (!image.includes(':')) image += ':latest';
                    const proxyHost = (location.hostname === 'localhost' || location.hostname === '127.0.0.1')
                        ? `https://${location.hostname}:4434`
                        : 'https://78.141.219.102.nip.io';
                    const pullUrl = `${proxyHost}/pull?image=${encodeURIComponent(image)}`;

                    try {
                        const resp = await fetch(pullUrl);
                        if (!resp.ok) throw new Error(await resp.text());
                        const buf = await resp.arrayBuffer();
                        await bootImportedImage(image, buf);
                        return { success: true, image, size_mb: (buf.byteLength / 1024 / 1024).toFixed(1) };
                    } catch (e) {
                        return { error: e.message };
                    }
                }
            });

            // Tool 3: Get container status
            navigator.modelContext.registerTool({
                name: 'get_status',
                description: 'Get the current status of the friscy container runtime — whether a container is running, which image, and network connectivity.',
                inputSchema: { type: 'object', properties: {} },
                async execute() {
                    return {
                        running: machineRunning,
                        tab: new URLSearchParams(location.search).get('example') || 'alpine',
                        network: netBridge && netBridge.isAvailable() ? 'connected' : 'disconnected',
                    };
                }
            });

            // Tool 4: Switch to a different example tab
            navigator.modelContext.registerTool({
                name: 'switch_tab',
                description: 'Switch to a different friscy example tab. Available tabs: "alpine" (Alpine Linux shell), "nodejs" (Node.js REPL), "server" (Go echo HTTP server), "import" (import Docker image).',
                inputSchema: {
                    type: 'object',
                    properties: {
                        tab: {
                            type: 'string',
                            description: 'Tab name: "alpine", "nodejs", "server", or "import"'
                        }
                    },
                    required: ['tab']
                },
                async execute({ tab }) {
                    const valid = ['alpine', 'nodejs', 'server', 'import'];
                    if (!valid.includes(tab)) return { error: `Invalid tab. Choose from: ${valid.join(', ')}` };
                    const u = new URL(location);
                    if (tab === 'alpine') u.searchParams.delete('example');
                    else u.searchParams.set('example', tab);
                    location.href = u;
                    return { success: true, switching_to: tab };
                }
            });

            console.log('[friscy] WebMCP tools registered: run_command, import_docker_image, get_status, switch_tab');
        }

        // --- Virtual keyboard / IME detection ---
        // Uses VirtualKeyboard API (Chrome 94+) or visualViewport fallback
        if ('virtualKeyboard' in navigator) {
            navigator.virtualKeyboard.overlaysContent = true;
            navigator.virtualKeyboard.addEventListener('geometrychange', () => {
                const kbRect = navigator.virtualKeyboard.boundingRect;
                const container = document.getElementById('terminal-container');
                if (kbRect.height > 0) {
                    container.style.paddingBottom = kbRect.height + 'px';
                } else {
                    container.style.paddingBottom = '';
                }
                if (typeof updateTerminalSize === 'function') updateTerminalSize();
            });
        } else if (window.visualViewport) {
            // Fallback: detect viewport shrink from soft keyboard
            const vv = window.visualViewport;
            let lastHeight = vv.height;
            vv.addEventListener('resize', () => {
                const container = document.getElementById('terminal-container');
                const diff = window.innerHeight - vv.height;
                if (diff > 100) {
                    // Keyboard is open — shrink terminal, scroll cursor into view
                    container.style.paddingBottom = diff + 'px';
                } else {
                    container.style.paddingBottom = '';
                }
                if (typeof updateTerminalSize === 'function') updateTerminalSize();
                lastHeight = vv.height;
            });
        }
    </script>
</body>
</html>
