#!/bin/bash
#
# friscy-pack: Package Docker container for browser execution
#
# Usage:
#   friscy-pack <image> [--output <dir>] [--aot]
#
# Examples:
#   friscy-pack alpine:latest
#   friscy-pack myapp:riscv64 --output dist/
#   friscy-pack python:3.11-alpine --aot  # Use AOT compilation

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
RUNTIME_DIR="${SCRIPT_DIR}/../runtime"
FRISCY_WASM="${RUNTIME_DIR}/build/friscy.wasm"
FRISCY_JS="${RUNTIME_DIR}/build/friscy.js"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log()  { echo -e "${GREEN}[friscy-pack]${NC} $1"; }
warn() { echo -e "${YELLOW}[friscy-pack]${NC} $1"; }
err()  { echo -e "${RED}[friscy-pack]${NC} $1"; exit 1; }

# Parse arguments
IMAGE=""
OUTPUT_DIR="./friscy-bundle"
USE_AOT=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --output|-o)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --aot)
            USE_AOT=true
            shift
            ;;
        --help|-h)
            echo "Usage: friscy-pack <image> [--output <dir>] [--aot]"
            echo ""
            echo "Package a Docker container for browser execution via friscy."
            echo ""
            echo "Options:"
            echo "  --output, -o <dir>  Output directory (default: ./friscy-bundle)"
            echo "  --aot               Use AOT compilation (faster, experimental)"
            echo "  --help, -h          Show this help"
            exit 0
            ;;
        *)
            IMAGE="$1"
            shift
            ;;
    esac
done

if [[ -z "$IMAGE" ]]; then
    err "No image specified. Usage: friscy-pack <image>"
fi

# Check dependencies
command -v docker >/dev/null 2>&1 || err "docker is required"
command -v jq >/dev/null 2>&1 || err "jq is required (apt install jq)"

log "Packaging: $IMAGE"
log "Output: $OUTPUT_DIR"

# Create output directory
mkdir -p "$OUTPUT_DIR"

# =============================================================================
# Step 1: Check if image is RISC-V, if not build it
# =============================================================================
log "Checking image architecture..."

# Try to inspect the image
ARCH=$(docker inspect "$IMAGE" 2>/dev/null | jq -r '.[0].Architecture' || echo "")

if [[ "$ARCH" == "riscv64" ]]; then
    log "Image is already RISC-V 64-bit"
    RISCV_IMAGE="$IMAGE"
else
    log "Image is $ARCH, need to build for RISC-V..."

    # Check if we have a Dockerfile
    if [[ -f "Dockerfile" ]]; then
        RISCV_IMAGE="${IMAGE%:*}:riscv64"
        log "Building $RISCV_IMAGE from Dockerfile..."

        docker buildx build \
            --platform linux/riscv64 \
            --load \
            -t "$RISCV_IMAGE" \
            . || err "Failed to build RISC-V image"
    else
        # Try to pull multi-arch image
        RISCV_IMAGE="$IMAGE"
        log "Pulling $IMAGE for linux/riscv64..."
        docker pull --platform linux/riscv64 "$IMAGE" 2>/dev/null || \
            err "Image not available for RISC-V and no Dockerfile found"
    fi
fi

# =============================================================================
# Step 2: Extract container filesystem
# =============================================================================
log "Extracting rootfs..."

CONTAINER_NAME="friscy-temp-$$"
docker create --platform linux/riscv64 --name "$CONTAINER_NAME" "$RISCV_IMAGE" /bin/sh >/dev/null

# Export filesystem
docker export "$CONTAINER_NAME" > "$OUTPUT_DIR/rootfs.tar"
log "Exported rootfs: $(du -h "$OUTPUT_DIR/rootfs.tar" | cut -f1)"

# Get container config
CONFIG=$(docker inspect "$CONTAINER_NAME")
ENTRYPOINT=$(echo "$CONFIG" | jq -r '.[0].Config.Entrypoint // empty | if type == "array" then .[] else . end')
CMD=$(echo "$CONFIG" | jq -r '.[0].Config.Cmd // empty | if type == "array" then .[] else . end')
WORKDIR=$(echo "$CONFIG" | jq -r '.[0].Config.WorkingDir // "/"')
ENV=$(echo "$CONFIG" | jq -r '.[0].Config.Env // [] | .[]')

# Cleanup
docker rm "$CONTAINER_NAME" >/dev/null

# Determine what to run
if [[ -n "$ENTRYPOINT" ]]; then
    RUN_CMD="$ENTRYPOINT $CMD"
elif [[ -n "$CMD" ]]; then
    RUN_CMD="$CMD"
else
    RUN_CMD="/bin/sh"
fi

log "Entrypoint: $RUN_CMD"
log "Workdir: $WORKDIR"

# =============================================================================
# Step 2.5: AOT Compilation (optional)
# =============================================================================
if [[ "$USE_AOT" == "true" ]]; then
    log "Running AOT compilation..."

    # Check for rv2wasm
    RV2WASM="${SCRIPT_DIR}/../aot/target/release/rv2wasm"
    if [[ ! -f "$RV2WASM" ]]; then
        RV2WASM="${SCRIPT_DIR}/../aot/target/debug/rv2wasm"
    fi

    if [[ ! -f "$RV2WASM" ]]; then
        warn "rv2wasm not found, attempting to build..."
        # Ensure cargo is findable (rustup installs to ~/.cargo/bin)
        [[ -d "$HOME/.cargo/bin" ]] && export PATH="$HOME/.cargo/bin:$PATH"
        if command -v cargo >/dev/null 2>&1; then
            (cd "${SCRIPT_DIR}/../aot" && cargo build --release) || {
                warn "Failed to build rv2wasm, skipping AOT"
                USE_AOT=false
            }
            RV2WASM="${SCRIPT_DIR}/../aot/target/release/rv2wasm"
        else
            warn "cargo not found, skipping AOT compilation"
            USE_AOT=false
        fi
    fi

    if [[ "$USE_AOT" == "true" && -f "$RV2WASM" ]]; then
        # Extract rootfs temporarily
        AOT_TMP=$(mktemp -d)
        tar -xf "$OUTPUT_DIR/rootfs.tar" -C "$AOT_TMP"

        # Find and compile RISC-V ELF binaries
        AOT_COUNT=0
        mkdir -p "$OUTPUT_DIR/aot"

        # Use process substitution to avoid subshell (so AOT_COUNT propagates)
        while read -r elf; do
            # Check if it's a RISC-V ELF (try file command, fallback to magic bytes)
            IS_RISCV=false
            if command -v file >/dev/null 2>&1; then
                if file "$elf" 2>/dev/null | grep -q "RISC-V"; then
                    IS_RISCV=true
                fi
            else
                # Fallback: check ELF magic (7f 45 4c 46) and e_machine=0xf3 (RISC-V)
                MAGIC=$(od -A n -t x1 -N 4 "$elf" 2>/dev/null | tr -d ' ')
                if [[ "$MAGIC" == "7f454c46" ]]; then
                    # e_machine is at offset 18 (2 bytes, little-endian)
                    EMACH=$(od -A n -t x1 -j 18 -N 2 "$elf" 2>/dev/null | tr -d ' ')
                    if [[ "$EMACH" == "f300" ]]; then
                        IS_RISCV=true
                    fi
                fi
            fi

            if [[ "$IS_RISCV" == "true" ]]; then
                REL_PATH="${elf#$AOT_TMP}"
                AOT_OUT="$OUTPUT_DIR/aot${REL_PATH}.wasm"
                mkdir -p "$(dirname "$AOT_OUT")"

                if "$RV2WASM" "$elf" -o "$AOT_OUT" 2>/dev/null; then
                    log "  AOT compiled: $REL_PATH"
                    AOT_COUNT=$((AOT_COUNT + 1))
                fi
            fi
        done < <(find "$AOT_TMP" -type f -executable 2>/dev/null)

        rm -rf "$AOT_TMP"
        log "AOT compilation complete: $AOT_COUNT binaries"
    fi
fi

# =============================================================================
# Step 3: Generate manifest
# =============================================================================
log "Generating manifest..."

AOT_JSON="[]"
if [[ "$USE_AOT" == "true" && -d "$OUTPUT_DIR/aot" ]]; then
    # Build JSON array of AOT-compiled files (relative paths)
    AOT_FILES=""
    while read -r wasm_file; do
        REL="${wasm_file#$OUTPUT_DIR/}"
        if [[ -n "$AOT_FILES" ]]; then
            AOT_FILES="$AOT_FILES, \"$REL\""
        else
            AOT_FILES="\"$REL\""
        fi
    done < <(find "$OUTPUT_DIR/aot" -name '*.wasm' -type f 2>/dev/null)
    if [[ -n "$AOT_FILES" ]]; then
        AOT_JSON="[$AOT_FILES]"
    fi
fi

cat > "$OUTPUT_DIR/manifest.json" << EOF
{
  "version": 1,
  "image": "$IMAGE",
  "entrypoint": "$(printf '%s' "$RUN_CMD")",
  "workdir": "$WORKDIR",
  "env": [
$(echo "$ENV" | sed 's/^/    "/; s/$/"/' | paste -sd ',' | sed 's/,/,\n/g')
  ],
  "aot": $AOT_JSON,
  "created": "$(date -Iseconds)"
}
EOF

# =============================================================================
# Step 4: Copy or build friscy runtime
# =============================================================================
if [[ -f "$FRISCY_WASM" ]]; then
    log "Copying pre-built friscy runtime..."
    cp "$FRISCY_WASM" "$OUTPUT_DIR/"
    cp "$FRISCY_JS" "$OUTPUT_DIR/"
else
    warn "Pre-built friscy not found, building..."
    (cd "$SCRIPT_DIR" && ./harness.sh) || err "Failed to build friscy"
    FRISCY_WASM="${RUNTIME_DIR}/build/friscy.wasm"
    FRISCY_JS="${RUNTIME_DIR}/build/friscy.js"
    cp "$FRISCY_WASM" "$OUTPUT_DIR/"
    cp "$FRISCY_JS" "$OUTPUT_DIR/"
fi

# =============================================================================
# Step 5: Generate HTML
# =============================================================================
log "Generating index.html..."
cp "${SCRIPT_DIR}/../friscy-pack-index.html.template" "$OUTPUT_DIR/index.html"

# =============================================================================
# Step 6: Summary
# =============================================================================
echo ""
log "Bundle created successfully!"
echo ""
echo -e "  ${BLUE}Output directory:${NC} $OUTPUT_DIR"
echo ""
echo "  Files:"
ls -lh "$OUTPUT_DIR" | tail -n +2 | while read line; do
    echo "    $line"
done
echo ""
echo -e "  ${GREEN}To run locally:${NC}"
echo "    cd $OUTPUT_DIR && python3 -m http.server 8080"
echo "    # Then open http://localhost:8080"
echo ""
echo -e "  ${GREEN}To deploy:${NC}"
echo "    Upload contents of $OUTPUT_DIR to any static hosting"
echo ""